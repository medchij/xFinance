{"version":3,"file":"443.js","mappings":"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","sources":["webpack://office-addin-taskpane-react-js/./node_modules/tabster/dist/tabster.esm.js"],"sourcesContent":["import { nativeFocus, KEYBORG_FOCUSIN, KEYBORG_FOCUSOUT, createKeyborg, disposeKeyborg } from 'keyborg';\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst TABSTER_ATTRIBUTE_NAME = \"data-tabster\";\nconst TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME = \"data-tabster-dummy\";\nconst FOCUSABLE_SELECTOR = /*#__PURE__*/[\"a[href]\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"*[tabindex]\", \"*[contenteditable]\", \"details > summary\", \"audio[controls]\", \"video[controls]\"].join(\", \");\nconst AsyncFocusSources = {\n  EscapeGroupper: 1,\n  Restorer: 2,\n  Deloser: 3\n};\nconst ObservedElementAccessibilities = {\n  Any: 0,\n  Accessible: 1,\n  Focusable: 2\n};\nconst ObservedElementRequestStatuses = {\n  Waiting: 0,\n  Succeeded: 1,\n  Canceled: 2,\n  TimedOut: 3\n};\nconst RestoreFocusOrders = {\n  History: 0,\n  DeloserDefault: 1,\n  RootDefault: 2,\n  DeloserFirst: 3,\n  RootFirst: 4\n};\nconst DeloserStrategies = {\n  /**\r\n   * If the focus is lost, the focus will be restored automatically using all available focus history.\r\n   * This is the default strategy.\r\n   */\n  Auto: 0,\n\n  /**\r\n   * If the focus is lost from this Deloser instance, the focus will not be restored automatically.\r\n   * The application might listen to the event and restore the focus manually.\r\n   * But if it is lost from another Deloser instance, the history of this Deloser could be used finding\r\n   * the element to focus.\r\n   */\n  Manual: 1\n};\nconst Visibilities = {\n  Invisible: 0,\n  PartiallyVisible: 1,\n  Visible: 2\n};\nconst RestorerTypes = {\n  Source: 0,\n  Target: 1\n};\nconst MoverDirections = {\n  Both: 0,\n  Vertical: 1,\n  Horizontal: 2,\n  Grid: 3,\n  GridLinear: 4 // Two-dimentional movement depending on the visual placement. Allows linear movement.\n\n};\nconst MoverKeys = {\n  ArrowUp: 1,\n  ArrowDown: 2,\n  ArrowLeft: 3,\n  ArrowRight: 4,\n  PageUp: 5,\n  PageDown: 6,\n  Home: 7,\n  End: 8\n};\nconst GroupperTabbabilities = {\n  Unlimited: 0,\n  Limited: 1,\n  LimitedTrapFocus: 2 // The focus is limited as above, plus trapped when inside.\n\n};\nconst GroupperMoveFocusActions = {\n  Enter: 1,\n  Escape: 2\n};\nconst SysDummyInputsPositions = {\n  Auto: 0,\n  Inside: 1,\n  Outside: 2 // Tabster will always place dummy inputs outside of the container.\n\n};\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterOnElement(tabster, element) {\n  var _a;\n\n  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;\n}\nfunction updateTabsterByAttribute(tabster, element, dispose) {\n  var _a, _b;\n\n  const newAttrValue = dispose || tabster._noop ? undefined : element.getAttribute(TABSTER_ATTRIBUTE_NAME);\n  let entry = tabster.storageEntry(element);\n  let newAttr;\n\n  if (newAttrValue) {\n    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {\n      try {\n        const newValue = JSON.parse(newAttrValue);\n\n        if (typeof newValue !== \"object\") {\n          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);\n        }\n\n        newAttr = {\n          string: newAttrValue,\n          object: newValue\n        };\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    } else {\n      return;\n    }\n  } else if (!entry) {\n    return;\n  }\n\n  if (!entry) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    entry = tabster.storageEntry(element, true);\n  }\n\n  if (!entry.tabster) {\n    entry.tabster = {};\n  }\n\n  const tabsterOnElement = entry.tabster || {};\n  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};\n  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};\n\n  for (const key of Object.keys(oldTabsterProps)) {\n    if (!newTabsterProps[key]) {\n      if (key === \"root\") {\n        const root = tabsterOnElement[key];\n\n        if (root) {\n          tabster.root.onRoot(root, true);\n        }\n      }\n\n      switch (key) {\n        case \"deloser\":\n        case \"root\":\n        case \"groupper\":\n        case \"modalizer\":\n        case \"restorer\":\n        case \"mover\":\n          // eslint-disable-next-line no-case-declarations\n          const part = tabsterOnElement[key];\n\n          if (part) {\n            part.dispose();\n            delete tabsterOnElement[key];\n          }\n\n          break;\n\n        case \"observed\":\n          delete tabsterOnElement[key];\n\n          if (tabster.observedElement) {\n            tabster.observedElement.onObservedElementUpdate(element);\n          }\n\n          break;\n\n        case \"focusable\":\n        case \"outline\":\n        case \"uncontrolled\":\n        case \"sys\":\n          delete tabsterOnElement[key];\n          break;\n      }\n    }\n  }\n\n  for (const key of Object.keys(newTabsterProps)) {\n    const sys = newTabsterProps.sys;\n\n    switch (key) {\n      case \"deloser\":\n        if (tabsterOnElement.deloser) {\n          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);\n        } else {\n          if (tabster.deloser) {\n            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Deloser API used before initialization, please call `getDeloser()`\");\n          }\n        }\n\n        break;\n\n      case \"root\":\n        if (tabsterOnElement.root) {\n          tabsterOnElement.root.setProps(newTabsterProps.root);\n        } else {\n          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);\n        }\n\n        tabster.root.onRoot(tabsterOnElement.root);\n        break;\n\n      case \"modalizer\":\n        if (tabsterOnElement.modalizer) {\n          tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);\n        } else {\n          if (tabster.modalizer) {\n            tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element, newTabsterProps.modalizer, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Modalizer API used before initialization, please call `getModalizer()`\");\n          }\n        }\n\n        break;\n\n      case \"restorer\":\n        if (tabsterOnElement.restorer) {\n          tabsterOnElement.restorer.setProps(newTabsterProps.restorer);\n        } else {\n          if (tabster.restorer) {\n            if (newTabsterProps.restorer) {\n              tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);\n            }\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Restorer API used before initialization, please call `getRestorer()`\");\n          }\n        }\n\n        break;\n\n      case \"focusable\":\n        tabsterOnElement.focusable = newTabsterProps.focusable;\n        break;\n\n      case \"groupper\":\n        if (tabsterOnElement.groupper) {\n          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);\n        } else {\n          if (tabster.groupper) {\n            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Groupper API used before initialization, please call `getGroupper()`\");\n          }\n        }\n\n        break;\n\n      case \"mover\":\n        if (tabsterOnElement.mover) {\n          tabsterOnElement.mover.setProps(newTabsterProps.mover);\n        } else {\n          if (tabster.mover) {\n            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Mover API used before initialization, please call `getMover()`\");\n          }\n        }\n\n        break;\n\n      case \"observed\":\n        if (tabster.observedElement) {\n          tabsterOnElement.observed = newTabsterProps.observed;\n          tabster.observedElement.onObservedElementUpdate(element);\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"ObservedElement API used before initialization, please call `getObservedElement()`\");\n        }\n\n        break;\n\n      case \"uncontrolled\":\n        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n        break;\n\n      case \"outline\":\n        if (tabster.outline) {\n          tabsterOnElement.outline = newTabsterProps.outline;\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"Outline API used before initialization, please call `getOutline()`\");\n        }\n\n        break;\n\n      case \"sys\":\n        tabsterOnElement.sys = newTabsterProps.sys;\n        break;\n\n      default:\n        console.error(`Unknown key '${key}' in data-tabster attribute value.`);\n    }\n  }\n\n  if (newAttr) {\n    entry.attr = newAttr;\n  } else {\n    if (Object.keys(tabsterOnElement).length === 0) {\n      delete entry.tabster;\n      delete entry.attr;\n    }\n\n    tabster.storageEntry(element, false);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Events sent by Tabster.\r\n */\nconst TabsterFocusInEventName = \"tabster:focusin\";\nconst TabsterFocusOutEventName = \"tabster:focusout\"; // Event is dispatched when Tabster wants to move focus as the result of\n// handling keyboard event. This allows to preventDefault() if you want to have\n// some custom logic.\n\nconst TabsterMoveFocusEventName = \"tabster:movefocus\";\n/**\r\n * Events sent by Deloser.\r\n */\n\nconst DeloserFocusLostEventName = \"tabster:deloser:focus-lost\";\n/**\r\n * Events to be sent to Deloser by the application.\r\n */\n\nconst DeloserRestoreFocusEventName = \"tabster:deloser:restore-focus\";\n/**\r\n * Events sent by Modalizer.\r\n */\n\nconst ModalizerActiveEventName = \"tabster:modalizer:active\";\nconst ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nconst ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nconst ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\n/**\r\n * Events sent by Mover.\r\n */\n\nconst MoverStateEventName = \"tabster:mover:state\";\n/**\r\n * Events to be sent to Mover by the application.\r\n */\n// Event that can be dispatched by the application to programmatically move\n// focus inside Mover.\n\nconst MoverMoveFocusEventName = \"tabster:mover:movefocus\"; // Event that can be dispatched by the application to forget or modify\n// memorized element in Mover with memorizeCurrent property.\n\nconst MoverMemorizedElementEventName = \"tabster:mover:memorized-element\";\n/**\r\n * Events sent by Groupper.\r\n */\n\n/**\r\n * Events to be sent to Groupper by the application.\r\n */\n// Event that can be dispatched by the application to programmatically enter\n// or escape Groupper.\n\nconst GroupperMoveFocusEventName = \"tabster:groupper:movefocus\";\n/**\r\n * Events sent by Restorer.\r\n */\n\nconst RestorerRestoreFocusEventName = \"tabster:restorer:restore-focus\";\n/**\r\n * Events sent by Root.\r\n */\n\nconst RootFocusEventName = \"tabster:root:focus\";\nconst RootBlurEventName = \"tabster:root:blur\"; // Node.js environments do not have CustomEvent and it is needed for the events to be\n// evaluated. It doesn't matter if it works or not in Node.js environment.\n// So, we just need to make sure that it doesn't throw undefined reference.\n\nconst CustomEvent_ = typeof CustomEvent !== \"undefined\" ? CustomEvent : function () {\n  /* no-op */\n};\nclass TabsterCustomEvent extends CustomEvent_ {\n  constructor(type, detail) {\n    super(type, {\n      bubbles: true,\n      cancelable: true,\n      composed: true,\n      detail\n    });\n    this.details = detail;\n  }\n\n}\nclass TabsterFocusInEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(TabsterFocusInEventName, detail);\n  }\n\n}\nclass TabsterFocusOutEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(TabsterFocusOutEventName, detail);\n  }\n\n}\nclass TabsterMoveFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(TabsterMoveFocusEventName, detail);\n  }\n\n}\nclass MoverStateEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(MoverStateEventName, detail);\n  }\n\n}\nclass MoverMoveFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(MoverMoveFocusEventName, detail);\n  }\n\n}\nclass MoverMemorizedElementEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(MoverMemorizedElementEventName, detail);\n  }\n\n}\nclass GroupperMoveFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(GroupperMoveFocusEventName, detail);\n  }\n\n}\nclass ModalizerActiveEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(ModalizerActiveEventName, detail);\n  }\n\n}\nclass ModalizerInactiveEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(ModalizerInactiveEventName, detail);\n  }\n\n}\nclass DeloserFocusLostEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(DeloserFocusLostEventName, detail);\n  }\n\n}\nclass DeloserRestoreFocusEvent extends TabsterCustomEvent {\n  constructor() {\n    super(DeloserRestoreFocusEventName);\n  }\n\n}\nclass RestorerRestoreFocusEvent extends TabsterCustomEvent {\n  constructor() {\n    super(RestorerRestoreFocusEventName);\n  }\n\n}\nclass RootFocusEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(RootFocusEventName, detail);\n  }\n\n}\nclass RootBlurEvent extends TabsterCustomEvent {\n  constructor(detail) {\n    super(RootBlurEventName, detail);\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _createMutationObserver = callback => new MutationObserver(callback);\n\nconst _createTreeWalker = (doc, root, whatToShow, filter) => doc.createTreeWalker(root, whatToShow, filter);\n\nconst _getParentNode = node => node ? node.parentNode : null;\n\nconst _getParentElement = element => element ? element.parentElement : null;\n\nconst _nodeContains = (parent, child) => !!(child && (parent === null || parent === void 0 ? void 0 : parent.contains(child)));\n\nconst _getActiveElement = doc => doc.activeElement;\n\nconst _querySelector = (element, selector) => element.querySelector(selector);\n\nconst _querySelectorAll = (element, selector) => Array.prototype.slice.call(element.querySelectorAll(selector), 0);\n\nconst _getElementById = (doc, id) => doc.getElementById(id);\n\nconst _getFirstChild = node => (node === null || node === void 0 ? void 0 : node.firstChild) || null;\n\nconst _getLastChild = node => (node === null || node === void 0 ? void 0 : node.lastChild) || null;\n\nconst _getNextSibling = node => (node === null || node === void 0 ? void 0 : node.nextSibling) || null;\n\nconst _getPreviousSibling = node => (node === null || node === void 0 ? void 0 : node.previousSibling) || null;\n\nconst _getFirstElementChild = element => (element === null || element === void 0 ? void 0 : element.firstElementChild) || null;\n\nconst _getLastElementChild = element => (element === null || element === void 0 ? void 0 : element.lastElementChild) || null;\n\nconst _getNextElementSibling = element => (element === null || element === void 0 ? void 0 : element.nextElementSibling) || null;\n\nconst _getPreviousElementSibling = element => (element === null || element === void 0 ? void 0 : element.previousElementSibling) || null;\n\nconst _appendChild = (parent, child) => parent.appendChild(child);\n\nconst _insertBefore = (parent, child, referenceChild) => parent.insertBefore(child, referenceChild);\n\nconst _getSelection = ref => {\n  var _a;\n\n  return ((_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.getSelection()) || null;\n};\n\nconst _getElementsByName = (referenceElement, name) => referenceElement.ownerDocument.getElementsByName(name);\n\nconst dom = {\n  createMutationObserver: _createMutationObserver,\n  createTreeWalker: _createTreeWalker,\n  getParentNode: _getParentNode,\n  getParentElement: _getParentElement,\n  nodeContains: _nodeContains,\n  getActiveElement: _getActiveElement,\n  querySelector: _querySelector,\n  querySelectorAll: _querySelectorAll,\n  getElementById: _getElementById,\n  getFirstChild: _getFirstChild,\n  getLastChild: _getLastChild,\n  getNextSibling: _getNextSibling,\n  getPreviousSibling: _getPreviousSibling,\n  getFirstElementChild: _getFirstElementChild,\n  getLastElementChild: _getLastElementChild,\n  getNextElementSibling: _getNextElementSibling,\n  getPreviousElementSibling: _getPreviousElementSibling,\n  appendChild: _appendChild,\n  insertBefore: _insertBefore,\n  getSelection: _getSelection,\n  getElementsByName: _getElementsByName\n};\nfunction setDOMAPI(domapi) {\n  for (const key of Object.keys(domapi)) {\n    dom[key] = domapi[key];\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nlet _isBrokenIE11;\n\nconst _DOMRect = typeof DOMRect !== \"undefined\" ? DOMRect : class {\n  constructor(x, y, width, height) {\n    this.left = x || 0;\n    this.top = y || 0;\n    this.right = (x || 0) + (width || 0);\n    this.bottom = (y || 0) + (height || 0);\n  }\n\n};\n\nlet _uidCounter = 0;\n\ntry {\n  // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n  // property as the docs define). Also `entityReferenceExpansion` argument is not\n  // optional. And it throws exception when the above arguments aren't there.\n  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n  _isBrokenIE11 = false;\n} catch (e) {\n  _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\nfunction getInstanceContext(getWindow) {\n  const win = getWindow();\n  let ctx = win.__tabsterInstanceContext;\n\n  if (!ctx) {\n    ctx = {\n      elementByUId: {},\n      basics: {\n        Promise: win.Promise || undefined,\n        WeakRef: win.WeakRef || undefined\n      },\n      containerBoundingRectCache: {},\n      lastContainerBoundingRectCacheId: 0,\n      fakeWeakRefs: [],\n      fakeWeakRefsStarted: false\n    };\n    win.__tabsterInstanceContext = ctx;\n  }\n\n  return ctx;\n}\nfunction disposeInstanceContext(win) {\n  const ctx = win.__tabsterInstanceContext;\n\n  if (ctx) {\n    ctx.elementByUId = {};\n    delete ctx.WeakRef;\n    ctx.containerBoundingRectCache = {};\n\n    if (ctx.containerBoundingRectCacheTimer) {\n      win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n    }\n\n    if (ctx.fakeWeakRefsTimer) {\n      win.clearTimeout(ctx.fakeWeakRefsTimer);\n    }\n\n    ctx.fakeWeakRefs = [];\n    delete win.__tabsterInstanceContext;\n  }\n}\nfunction createWeakMap(win) {\n  const ctx = win.__tabsterInstanceContext;\n  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();\n}\nfunction hasSubFocusable(element) {\n  return !!element.querySelector(FOCUSABLE_SELECTOR);\n}\n\nclass FakeWeakRef {\n  constructor(target) {\n    this._target = target;\n  }\n\n  deref() {\n    return this._target;\n  }\n\n  static cleanup(fwr, forceRemove) {\n    if (!fwr._target) {\n      return true;\n    }\n\n    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {\n      delete fwr._target;\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass WeakHTMLElement {\n  constructor(getWindow, element, data) {\n    const context = getInstanceContext(getWindow);\n    let ref;\n\n    if (context.WeakRef) {\n      ref = new context.WeakRef(element);\n    } else {\n      ref = new FakeWeakRef(element);\n      context.fakeWeakRefs.push(ref);\n    }\n\n    this._ref = ref;\n    this._data = data;\n  }\n\n  get() {\n    const ref = this._ref;\n    let element;\n\n    if (ref) {\n      element = ref.deref();\n\n      if (!element) {\n        delete this._ref;\n      }\n    }\n\n    return element;\n  }\n\n  getData() {\n    return this._data;\n  }\n\n}\nfunction cleanupFakeWeakRefs(getWindow, forceRemove) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefs = context.fakeWeakRefs.filter(e => !FakeWeakRef.cleanup(e, forceRemove));\n}\nfunction startFakeWeakRefsCleanup(getWindow) {\n  const context = getInstanceContext(getWindow);\n\n  if (!context.fakeWeakRefsStarted) {\n    context.fakeWeakRefsStarted = true;\n    context.WeakRef = getWeakRef(context);\n  }\n\n  if (!context.fakeWeakRefsTimer) {\n    context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n      context.fakeWeakRefsTimer = undefined;\n      cleanupFakeWeakRefs(getWindow);\n      startFakeWeakRefsCleanup(getWindow);\n    }, 2 * 60 * 1000); // 2 minutes.\n  }\n}\nfunction stopFakeWeakRefsCleanupAndClearStorage(getWindow) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefsStarted = false;\n\n  if (context.fakeWeakRefsTimer) {\n    getWindow().clearTimeout(context.fakeWeakRefsTimer);\n    context.fakeWeakRefsTimer = undefined;\n    context.fakeWeakRefs = [];\n  }\n}\nfunction createElementTreeWalker(doc, root, acceptNode) {\n  // IE11 will throw an exception when the TreeWalker root is not an Element.\n  if (root.nodeType !== Node.ELEMENT_NODE) {\n    return undefined;\n  } // TypeScript isn't aware of IE11 behaving badly.\n\n\n  const filter = _isBrokenIE11 ? acceptNode : {\n    acceptNode\n  };\n  return dom.createTreeWalker(doc, root, NodeFilter.SHOW_ELEMENT, filter, // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n  false\n  /* Last argument is not optional for IE11! */\n  );\n}\nfunction getBoundingRect(getWindow, element) {\n  let cacheId = element.__tabsterCacheId;\n  const context = getInstanceContext(getWindow);\n  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : undefined;\n\n  if (cached) {\n    return cached.rect;\n  }\n\n  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;\n\n  if (!scrollingElement) {\n    return new _DOMRect();\n  } // A bounding rect of the top-level element contains the whole page regardless of the\n  // scrollbar. So, we improvise a little and limiting the final result...\n\n\n  let left = 0;\n  let top = 0;\n  let right = scrollingElement.clientWidth;\n  let bottom = scrollingElement.clientHeight;\n\n  if (element !== scrollingElement) {\n    const r = element.getBoundingClientRect();\n    left = Math.max(left, r.left);\n    top = Math.max(top, r.top);\n    right = Math.min(right, r.right);\n    bottom = Math.min(bottom, r.bottom);\n  }\n\n  const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);\n\n  if (!cacheId) {\n    cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n    element.__tabsterCacheId = cacheId;\n  }\n\n  context.containerBoundingRectCache[cacheId] = {\n    rect,\n    element\n  };\n\n  if (!context.containerBoundingRectCacheTimer) {\n    context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n      context.containerBoundingRectCacheTimer = undefined;\n\n      for (const cId of Object.keys(context.containerBoundingRectCache)) {\n        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;\n      }\n\n      context.containerBoundingRectCache = {};\n    }, 50);\n  }\n\n  return rect;\n}\nfunction isElementVerticallyVisibleInContainer(getWindow, element, tolerance) {\n  const container = getScrollableContainer(element);\n\n  if (!container) {\n    return false;\n  }\n\n  const containerRect = getBoundingRect(getWindow, container);\n  const elementRect = element.getBoundingClientRect();\n  const intersectionTolerance = elementRect.height * (1 - tolerance);\n  const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);\n  const totalIntersection = topIntersection + bottomIntersection;\n  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;\n}\nfunction scrollIntoView(getWindow, element, alignToTop) {\n  // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n  // it scrolls all of them, not just the deepest one. So, trying to work it around.\n  const container = getScrollableContainer(element);\n\n  if (container) {\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n\n    if (alignToTop) {\n      container.scrollTop += elementRect.top - containerRect.top;\n    } else {\n      container.scrollTop += elementRect.bottom - containerRect.bottom;\n    }\n  }\n}\nfunction getScrollableContainer(element) {\n  const doc = element.ownerDocument;\n\n  if (doc) {\n    for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {\n      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {\n        return el;\n      }\n    }\n\n    return doc.documentElement;\n  }\n\n  return null;\n}\nfunction makeFocusIgnored(element) {\n  element.__shouldIgnoreFocus = true;\n}\nfunction shouldIgnoreFocus(element) {\n  return !!element.__shouldIgnoreFocus;\n}\nfunction getUId(wnd) {\n  const rnd = new Uint32Array(4);\n\n  if (wnd.crypto && wnd.crypto.getRandomValues) {\n    wnd.crypto.getRandomValues(rnd);\n  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n    wnd.msCrypto.getRandomValues(rnd);\n  } else {\n    for (let i = 0; i < rnd.length; i++) {\n      rnd[i] = 0xffffffff * Math.random();\n    }\n  }\n\n  const srnd = [];\n\n  for (let i = 0; i < rnd.length; i++) {\n    srnd.push(rnd[i].toString(36));\n  }\n\n  srnd.push(\"|\");\n  srnd.push((++_uidCounter).toString(36));\n  srnd.push(\"|\");\n  srnd.push(Date.now().toString(36));\n  return srnd.join(\"\");\n}\nfunction getElementUId(getWindow, element) {\n  const context = getInstanceContext(getWindow);\n  let uid = element.__tabsterElementUID;\n\n  if (!uid) {\n    uid = element.__tabsterElementUID = getUId(getWindow());\n  }\n\n  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {\n    context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n  }\n\n  return uid;\n}\nfunction getWindowUId(win) {\n  let uid = win.__tabsterCrossOriginWindowUID;\n\n  if (!uid) {\n    uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n  }\n\n  return uid;\n}\nfunction clearElementCache(getWindow, parent) {\n  const context = getInstanceContext(getWindow);\n\n  for (const key of Object.keys(context.elementByUId)) {\n    const wel = context.elementByUId[key];\n    const el = wel && wel.get();\n\n    if (el && parent) {\n      if (!dom.nodeContains(parent, el)) {\n        continue;\n      }\n    }\n\n    delete context.elementByUId[key];\n  }\n} // IE11 doesn't have document.contains()...\n\nfunction documentContains(doc, element) {\n  return dom.nodeContains(doc === null || doc === void 0 ? void 0 : doc.body, element);\n}\nfunction matchesSelector(element, selector) {\n  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;\n  return matches && matches.call(element, selector);\n}\nfunction getPromise(getWindow) {\n  const context = getInstanceContext(getWindow);\n\n  if (context.basics.Promise) {\n    return context.basics.Promise;\n  }\n\n  throw new Error(\"No Promise defined.\");\n}\nfunction getWeakRef(context) {\n  return context.basics.WeakRef;\n}\nlet _lastTabsterPartId = 0;\nclass TabsterPart {\n  constructor(tabster, element, props) {\n    const getWindow = tabster.getWindow;\n    this._tabster = tabster;\n    this._element = new WeakHTMLElement(getWindow, element);\n    this._props = { ...props\n    };\n    this.id = \"i\" + ++_lastTabsterPartId;\n  }\n\n  getElement() {\n    return this._element.get();\n  }\n\n  getProps() {\n    return this._props;\n  }\n\n  setProps(props) {\n    this._props = { ...props\n    };\n  }\n\n}\n/**\r\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\r\n */\n\nclass DummyInput {\n  constructor(getWindow, isOutside, props, element, fixedTarget) {\n    var _a;\n\n    this._focusIn = e => {\n      if (this._fixedTarget) {\n        const target = this._fixedTarget.get();\n\n        if (target) {\n          nativeFocus(target);\n        }\n\n        return;\n      }\n\n      const input = this.input;\n\n      if (this.onFocusIn && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusIn(this, this._isBackward(true, input, relatedTarget), relatedTarget);\n      }\n    };\n\n    this._focusOut = e => {\n      if (this._fixedTarget) {\n        return;\n      }\n\n      this.useDefaultAction = false;\n      const input = this.input;\n\n      if (this.onFocusOut && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusOut(this, this._isBackward(false, input, relatedTarget), relatedTarget);\n      }\n    };\n\n    const win = getWindow();\n    const input = win.document.createElement(\"i\");\n    input.tabIndex = 0;\n    input.setAttribute(\"role\", \"none\");\n    input.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, \"\");\n    input.setAttribute(\"aria-hidden\", \"true\");\n    const style = input.style;\n    style.position = \"fixed\";\n    style.width = style.height = \"1px\";\n    style.opacity = \"0.001\";\n    style.zIndex = \"-1\";\n    style.setProperty(\"content-visibility\", \"hidden\");\n    makeFocusIgnored(input);\n    this.input = input;\n    this.isFirst = props.isFirst;\n    this.isOutside = isOutside;\n    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;\n    this._fixedTarget = fixedTarget;\n    input.addEventListener(\"focusin\", this._focusIn);\n    input.addEventListener(\"focusout\", this._focusOut);\n    input.__tabsterDummyContainer = element;\n\n    if (this._isPhantom) {\n      this._disposeTimer = win.setTimeout(() => {\n        delete this._disposeTimer;\n        this.dispose();\n      }, 0);\n\n      this._clearDisposeTimeout = () => {\n        if (this._disposeTimer) {\n          win.clearTimeout(this._disposeTimer);\n          delete this._disposeTimer;\n        }\n\n        delete this._clearDisposeTimeout;\n      };\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    if (this._clearDisposeTimeout) {\n      this._clearDisposeTimeout();\n    }\n\n    const input = this.input;\n\n    if (!input) {\n      return;\n    }\n\n    delete this._fixedTarget;\n    delete this.onFocusIn;\n    delete this.onFocusOut;\n    delete this.input;\n    input.removeEventListener(\"focusin\", this._focusIn);\n    input.removeEventListener(\"focusout\", this._focusOut);\n    delete input.__tabsterDummyContainer;\n    (_a = dom.getParentNode(input)) === null || _a === void 0 ? void 0 : _a.removeChild(input);\n  }\n\n  setTopLeft(top, left) {\n    var _a;\n\n    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;\n\n    if (style) {\n      style.top = `${top}px`;\n      style.left = `${left}px`;\n    }\n  }\n\n  _isBackward(isIn, current, previous) {\n    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);\n  }\n\n}\nconst DummyInputManagerPriorities = {\n  Root: 1,\n  Modalizer: 2,\n  Mover: 3,\n  Groupper: 4\n};\nclass DummyInputManager {\n  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._element = element;\n    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);\n  }\n\n  _setHandlers(onFocusIn, onFocusOut) {\n    this._onFocusIn = onFocusIn;\n    this._onFocusOut = onFocusOut;\n  }\n\n  moveOut(backwards) {\n    var _a;\n\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);\n  }\n\n  moveOutWithDefaultAction(backwards, relatedEvent) {\n    var _a;\n\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards, relatedEvent);\n  }\n\n  getHandler(isIn) {\n    return isIn ? this._onFocusIn : this._onFocusOut;\n  }\n\n  setTabbable(tabbable) {\n    var _a;\n\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);\n  }\n\n  dispose() {\n    if (this._instance) {\n      this._instance.dispose(this);\n\n      delete this._instance;\n    }\n\n    delete this._onFocusIn;\n    delete this._onFocusOut;\n  }\n\n  static moveWithPhantomDummy(tabster, element, // The target element to move to or out of.\n  moveOutOfElement, // Whether to move out of the element or into it.\n  isBackward, // Are we tabbing of shift-tabbing?\n  relatedEvent // The event that triggered the move.\n  ) {\n    // Phantom dummy is a hack to use browser's default action to move\n    // focus from a specific point in the application to the next/previous\n    // element. Default action is needed because next focusable element\n    // is not always available to focus directly (for example, next focusable\n    // is inside isolated iframe) or for uncontrolled areas we want to make\n    // sure that something that controls it takes care of the focusing.\n    // It works in a way that during the Tab key handling, we create a dummy\n    // input element, place it to the specific place in the DOM and focus it,\n    // then the default action of the Tab press will move focus from our dummy\n    // input. And we remove it from the DOM right after that.\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    });\n    const input = dummy.input;\n\n    if (input) {\n      let parent;\n      let insertBefore; // Let's say we have a following DOM structure:\n      // <div>\n      //   <button>Button1</button>\n      //   <div id=\"uncontrolled\" data-tabster={uncontrolled: {}}>\n      //     <button>Button2</button>\n      //     <button>Button3</button>\n      //   </div>\n      //   <button>Button4</button>\n      // </div>\n      //\n      // We pass the \"uncontrolled\" div as the element to move to or out of.\n      //\n      // When we pass moveOutOfElement=true and isBackward=false,\n      // the phantom dummy input will be inserted before Button4.\n      //\n      // When we pass moveOutOfElement=true and isBackward=true, there are\n      // two cases. If the uncontrolled element is focusable (has tabindex=0),\n      // the phantom dummy input will be inserted after Button1. If the\n      // uncontrolled element is not focusable, the phantom dummy input will be\n      // inserted before Button2.\n      //\n      // When we pass moveOutOfElement=false and isBackward=false, the\n      // phantom dummy input will be inserted after Button1.\n      //\n      // When we pass moveOutOfElement=false and isBackward=true, the phantom\n      // dummy input will be inserted before Button4.\n      //\n      // And we have a corner case for <body> and we make sure that the inserted\n      // dummy is inserted properly when there are existing permanent dummies.\n\n      if (element.tagName === \"BODY\") {\n        // We cannot insert elements outside of BODY.\n        parent = element;\n        insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getFirstElementChild(element) : null;\n      } else {\n        if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element, false, true, true))) {\n          parent = element;\n          insertBefore = isBackward ? element.firstElementChild : null;\n        } else {\n          parent = dom.getParentElement(element);\n          insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element : dom.getNextElementSibling(element);\n        }\n\n        let potentialDummy;\n        let dummyFor;\n\n        do {\n          // This is a safety pillow for the cases when someone, combines\n          // groupper with uncontrolled on the same node. Which is technically\n          // not correct, but moving into the container element via its dummy\n          // input would produce a correct behaviour in uncontrolled mode.\n          potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getPreviousElementSibling(insertBefore) : insertBefore;\n          dummyFor = getDummyInputContainer(potentialDummy);\n\n          if (dummyFor === element) {\n            insertBefore = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : dom.getNextElementSibling(potentialDummy);\n          } else {\n            dummyFor = null;\n          }\n        } while (dummyFor);\n      }\n\n      if (parent === null || parent === void 0 ? void 0 : parent.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"root\",\n        owner: parent,\n        next: null,\n        relatedEvent\n      }))) {\n        dom.insertBefore(parent, input, insertBefore);\n        nativeFocus(input);\n      }\n    }\n  }\n\n  static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    }, undefined, new WeakHTMLElement(tabster.getWindow, targetElement));\n    const input = dummy.input;\n\n    if (input) {\n      let dummyParent;\n      let insertBefore;\n\n      if (hasSubFocusable(sourceElement) && !isBackward) {\n        dummyParent = sourceElement;\n        insertBefore = dom.getFirstElementChild(sourceElement);\n      } else {\n        dummyParent = dom.getParentElement(sourceElement);\n        insertBefore = isBackward ? sourceElement : dom.getNextElementSibling(sourceElement);\n      }\n\n      if (dummyParent) {\n        dom.insertBefore(dummyParent, input, insertBefore);\n      }\n    }\n  }\n\n}\n\nfunction setDummyInputDebugValue(dummy, wrappers) {\n  var _a;\n\n  const what = {\n    1: \"Root\",\n    2: \"Modalizer\",\n    3: \"Mover\",\n    4: \"Groupper\"\n  };\n  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map(w => `(${what[w.priority]}, tabbable=${w.tabbable})`)].join(\", \"));\n}\n\nclass DummyInputObserver {\n  constructor(win) {\n    this._updateQueue = new Set();\n    this._lastUpdateQueueTime = 0;\n    this._changedParents = new WeakSet();\n    this._dummyElements = [];\n    this._dummyCallbacks = new WeakMap();\n\n    this._domChanged = parent => {\n      var _a;\n\n      if (this._changedParents.has(parent)) {\n        return;\n      }\n\n      this._changedParents.add(parent);\n\n      if (this._updateDummyInputsTimer) {\n        return;\n      }\n\n      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n        delete this._updateDummyInputsTimer;\n\n        for (const ref of this._dummyElements) {\n          const dummyElement = ref.get();\n\n          if (dummyElement) {\n            const callback = this._dummyCallbacks.get(dummyElement);\n\n            if (callback) {\n              const dummyParent = dom.getParentNode(dummyElement);\n\n              if (!dummyParent || this._changedParents.has(dummyParent)) {\n                callback();\n              }\n            }\n          }\n        }\n\n        this._changedParents = new WeakSet();\n      }, _updateDummyInputsTimeout);\n    };\n\n    this._win = win;\n  }\n\n  add(dummy, callback) {\n    if (!this._dummyCallbacks.has(dummy) && this._win) {\n      this._dummyElements.push(new WeakHTMLElement(this._win, dummy));\n\n      this._dummyCallbacks.set(dummy, callback);\n\n      this.domChanged = this._domChanged;\n    }\n  }\n\n  remove(dummy) {\n    this._dummyElements = this._dummyElements.filter(ref => {\n      const element = ref.get();\n      return element && element !== dummy;\n    });\n\n    this._dummyCallbacks.delete(dummy);\n\n    if (this._dummyElements.length === 0) {\n      delete this.domChanged;\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (this._updateTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    if (this._updateDummyInputsTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);\n      delete this._updateDummyInputsTimer;\n    }\n\n    this._changedParents = new WeakSet();\n    this._dummyCallbacks = new WeakMap();\n    this._dummyElements = [];\n\n    this._updateQueue.clear();\n\n    delete this.domChanged;\n    delete this._win;\n  }\n\n  updatePositions(compute) {\n    if (!this._win) {\n      // As this is a public method, we make sure that it has no effect when\n      // called after dispose().\n      return;\n    }\n\n    this._updateQueue.add(compute);\n\n    this._lastUpdateQueueTime = Date.now();\n\n    this._scheduledUpdatePositions();\n  }\n\n  _scheduledUpdatePositions() {\n    var _a;\n\n    if (this._updateTimer) {\n      return;\n    }\n\n    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n      delete this._updateTimer; // updatePositions() might be called quite a lot during the scrolling.\n      // So, instead of clearing the timeout and scheduling a new one, we\n      // check if enough time has passed since the last updatePositions() call\n      // and only schedule a new one if not.\n      // At maximum, we will update dummy inputs positions\n      // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n\n      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {\n        // A cache for current bulk of updates to reduce getComputedStyle() calls.\n        const scrollTopLeftCache = new Map();\n        const setTopLeftCallbacks = [];\n\n        for (const compute of this._updateQueue) {\n          setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n        }\n\n        this._updateQueue.clear(); // We're splitting the computation of offsets and setting them to avoid extra\n        // reflows.\n\n\n        for (const setTopLeft of setTopLeftCallbacks) {\n          setTopLeft();\n        } // Explicitly clear to not hold references till the next garbage collection.\n\n\n        scrollTopLeftCache.clear();\n      } else {\n        this._scheduledUpdatePositions();\n      }\n    }, _updateDummyInputsTimeout);\n  }\n\n}\n/**\r\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\r\n */\n\nclass DummyInputManagerCore {\n  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._wrappers = [];\n    this._isOutside = false;\n    this._transformElements = new Set();\n\n    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    this.moveOut = backwards => {\n      var _a;\n\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (firstInput && lastInput && element) {\n          let toFocus;\n\n          if (backwards) {\n            firstInput.tabIndex = 0;\n            toFocus = firstInput;\n          } else {\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n    /**\r\n     * Prepares to move focus out of the given element by focusing\r\n     * one of the dummy inputs and setting the `useDefaultAction` flag\r\n     * @param backwards focus moving to an element behind the given element\r\n     */\n\n\n    this.moveOutWithDefaultAction = (backwards, relatedEvent) => {\n      var _a;\n\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n\n      if (first && last) {\n        // For the sake of performance optimization, the dummy input\n        // position in the DOM updates asynchronously from the DOM change.\n        // Calling _ensurePosition() to make sure the position is correct.\n        this._ensurePosition();\n\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (firstInput && lastInput && element) {\n          let toFocus;\n\n          if (backwards) {\n            if (!first.isOutside && this._tabster.focusable.isFocusable(element, true, true, true)) {\n              toFocus = element;\n            } else {\n              first.useDefaultAction = true;\n              firstInput.tabIndex = 0;\n              toFocus = firstInput;\n            }\n          } else {\n            last.useDefaultAction = true;\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n\n          if (toFocus && element.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"root\",\n            owner: element,\n            next: null,\n            relatedEvent\n          }))) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n\n    this.setTabbable = (manager, tabbable) => {\n      var _a, _b;\n\n      for (const w of this._wrappers) {\n        if (w.manager === manager) {\n          w.tabbable = tabbable;\n          break;\n        }\n      }\n\n      const wrapper = this._getCurrent();\n\n      if (wrapper) {\n        const tabIndex = wrapper.tabbable ? 0 : -1;\n        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;\n\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n\n        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;\n\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n      }\n    };\n    /**\r\n     * Adds dummy inputs as the first and last child of the given element\r\n     * Called each time the children under the element is mutated\r\n     */\n\n\n    this._addDummyInputs = () => {\n      if (this._addTimer) {\n        return;\n      }\n\n      this._addTimer = this._getWindow().setTimeout(() => {\n        delete this._addTimer;\n\n        this._ensurePosition();\n\n        if (process.env.NODE_ENV === 'development') {\n          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n\n        this._addTransformOffsets();\n      }, 0);\n    };\n\n    this._addTransformOffsets = () => {\n      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);\n    };\n\n    this._computeTransformOffsets = scrollTopLeftCache => {\n      var _a, _b;\n\n      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);\n      const transformElements = this._transformElements;\n      const newTransformElements = new Set();\n      let scrollTop = 0;\n      let scrollLeft = 0;\n\n      const win = this._getWindow();\n\n      for (let element = from; element && element.nodeType === Node.ELEMENT_NODE; element = dom.getParentElement(element)) {\n        let scrollTopLeft = scrollTopLeftCache.get(element); // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n        // so we cache the result across all elements in the current bulk.\n\n        if (scrollTopLeft === undefined) {\n          const transform = win.getComputedStyle(element).transform;\n\n          if (transform && transform !== \"none\") {\n            scrollTopLeft = {\n              scrollTop: element.scrollTop,\n              scrollLeft: element.scrollLeft\n            };\n          }\n\n          scrollTopLeftCache.set(element, scrollTopLeft || null);\n        }\n\n        if (scrollTopLeft) {\n          newTransformElements.add(element);\n\n          if (!transformElements.has(element)) {\n            element.addEventListener(\"scroll\", this._addTransformOffsets);\n          }\n\n          scrollTop += scrollTopLeft.scrollTop;\n          scrollLeft += scrollTopLeft.scrollLeft;\n        }\n      }\n\n      for (const el of transformElements) {\n        if (!newTransformElements.has(el)) {\n          el.removeEventListener(\"scroll\", this._addTransformOffsets);\n        }\n      }\n\n      this._transformElements = newTransformElements;\n      return () => {\n        var _a, _b;\n\n        (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.setTopLeft(scrollTop, scrollLeft);\n        (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.setTopLeft(scrollTop, scrollLeft);\n      };\n    };\n\n    const el = element.get();\n\n    if (!el) {\n      throw new Error(\"No element\");\n    }\n\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._callForDefaultAction = callForDefaultAction;\n    const instance = el.__tabsterDummy;\n\n    (instance || this)._wrappers.push({\n      manager,\n      priority,\n      tabbable: true\n    });\n\n    if (instance) {\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);\n      }\n\n      return instance;\n    }\n\n    el.__tabsterDummy = this; // Some elements allow only specific types of direct descendants and we need to\n    // put our dummy inputs inside or outside of the element accordingly.\n\n    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;\n    const tagName = el.tagName;\n    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === \"UL\" || tagName === \"OL\" || tagName === \"TABLE\") && !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\") : forcedDummyPosition === SysDummyInputsPositions.Outside;\n    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: true\n    }, element);\n    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: false\n    }, element); // We will be checking dummy input parents to see if their child list have changed.\n    // So, it is enough to have just one of the inputs observed, because\n    // both dummy inputs always have the same parent.\n\n    const dummyElement = this._firstDummy.input;\n    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n    this._firstDummy.onFocusIn = this._onFocusIn;\n    this._firstDummy.onFocusOut = this._onFocusOut;\n    this._lastDummy.onFocusIn = this._onFocusIn;\n    this._lastDummy.onFocusOut = this._onFocusOut;\n    this._element = element;\n\n    this._addDummyInputs();\n  }\n\n  dispose(manager, force) {\n    var _a, _b, _c, _d;\n\n    const wrappers = this._wrappers = this._wrappers.filter(w => w.manager !== manager && !force);\n\n    if (process.env.NODE_ENV === 'development') {\n      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);\n      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);\n    }\n\n    if (wrappers.length === 0) {\n      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;\n\n      for (const el of this._transformElements) {\n        el.removeEventListener(\"scroll\", this._addTransformOffsets);\n      }\n\n      this._transformElements.clear();\n\n      const win = this._getWindow();\n\n      if (this._addTimer) {\n        win.clearTimeout(this._addTimer);\n        delete this._addTimer;\n      }\n\n      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n      dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();\n      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n\n  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {\n    var _a;\n\n    const wrapper = this._getCurrent();\n\n    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {\n      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);\n    }\n  }\n\n  _getCurrent() {\n    this._wrappers.sort((a, b) => {\n      if (a.tabbable !== b.tabbable) {\n        return a.tabbable ? -1 : 1;\n      }\n\n      return a.priority - b.priority;\n    });\n\n    return this._wrappers[0];\n  }\n\n  _ensurePosition() {\n    var _a, _b, _c;\n\n    const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n    const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n    const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;\n\n    if (!element || !firstDummyInput || !lastDummyInput) {\n      return;\n    }\n\n    if (this._isOutside) {\n      const elementParent = dom.getParentNode(element);\n\n      if (elementParent) {\n        const nextSibling = dom.getNextSibling(element);\n\n        if (nextSibling !== lastDummyInput) {\n          dom.insertBefore(elementParent, lastDummyInput, nextSibling);\n        }\n\n        if (dom.getPreviousElementSibling(element) !== firstDummyInput) {\n          dom.insertBefore(elementParent, firstDummyInput, element);\n        }\n      }\n    } else {\n      if (dom.getLastElementChild(element) !== lastDummyInput) {\n        dom.appendChild(element, lastDummyInput);\n      }\n\n      const firstElementChild = dom.getFirstElementChild(element);\n\n      if (firstElementChild && firstElementChild !== firstDummyInput && firstElementChild.parentNode) {\n        dom.insertBefore(firstElementChild.parentNode, firstDummyInput, firstElementChild);\n      }\n    }\n  }\n\n}\n\nfunction getLastChild$2(container) {\n  let lastChild = null;\n\n  for (let i = dom.getLastElementChild(container); i; i = dom.getLastElementChild(i)) {\n    lastChild = i;\n  }\n\n  return lastChild || undefined;\n}\nfunction getAdjacentElement(from, prev) {\n  let cur = from;\n  let adjacent = null;\n\n  while (cur && !adjacent) {\n    adjacent = prev ? dom.getPreviousElementSibling(cur) : dom.getNextElementSibling(cur);\n    cur = dom.getParentElement(cur);\n  }\n\n  return adjacent || undefined;\n}\nfunction augmentAttribute(tabster, element, name, value // Restore original value when undefined.\n) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const entry = tabster.storageEntry(element, true);\n  let ret = false;\n\n  if (!entry.aug) {\n    if (value === undefined) {\n      return ret;\n    }\n\n    entry.aug = {};\n  }\n\n  if (value === undefined) {\n    if (name in entry.aug) {\n      const origVal = entry.aug[name];\n      delete entry.aug[name];\n\n      if (origVal === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, origVal);\n      }\n\n      ret = true;\n    }\n  } else {\n    let origValue;\n\n    if (!(name in entry.aug)) {\n      origValue = element.getAttribute(name);\n    }\n\n    if (origValue !== undefined && origValue !== value) {\n      entry.aug[name] = origValue;\n\n      if (value === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value);\n      }\n\n      ret = true;\n    }\n  }\n\n  if (value === undefined && Object.keys(entry.aug).length === 0) {\n    delete entry.aug;\n    tabster.storageEntry(element, false);\n  }\n\n  return ret;\n}\nfunction isDisplayNone(element) {\n  var _a, _b;\n\n  const elementDocument = element.ownerDocument;\n  const computedStyle = (_a = elementDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(element); // offsetParent is null for elements with display:none, display:fixed and for <body>.\n\n  if (element.offsetParent === null && elementDocument.body !== element && (computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) !== \"fixed\") {\n    return true;\n  } // For our purposes of looking for focusable elements, visibility:hidden has the same\n  // effect as display:none.\n\n\n  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.visibility) === \"hidden\") {\n    return true;\n  } // if an element has display: fixed, we need to check if it is also hidden with CSS,\n  // or within a parent hidden with CSS\n\n\n  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) === \"fixed\") {\n    if (computedStyle.display === \"none\") {\n      return true;\n    }\n\n    if (((_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null && elementDocument.body !== element.parentElement) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction isRadio(element) {\n  return element.tagName === \"INPUT\" && !!element.name && element.type === \"radio\";\n}\nfunction getRadioButtonGroup(element) {\n  if (!isRadio(element)) {\n    return;\n  }\n\n  const name = element.name;\n  let radioButtons = Array.from(dom.getElementsByName(element, name));\n  let checked;\n  radioButtons = radioButtons.filter(el => {\n    if (isRadio(el)) {\n      if (el.checked) {\n        checked = el;\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    name,\n    buttons: new Set(radioButtons),\n    checked\n  };\n}\n/**\r\n * If the passed element is Tabster dummy input, returns the container element this dummy input belongs to.\r\n * @param element Element to check for being dummy input.\r\n * @returns Dummy input container element (if the passed element is a dummy input) or null.\r\n */\n\nfunction getDummyInputContainer(element) {\n  var _a;\n\n  return ((_a = element === null || element === void 0 ? void 0 : element.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) || null;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterAttribute(props, plain) {\n  const attr = JSON.stringify(props);\n\n  if (plain === true) {\n    return attr;\n  }\n\n  return {\n    [TABSTER_ATTRIBUTE_NAME]: attr\n  };\n}\n/**\r\n * Updates Tabster props object with new props.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param props current Tabster props to update.\r\n * @param newProps new Tabster props to add.\r\n *  When the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction mergeTabsterProps(props, newProps) {\n  for (const key of Object.keys(newProps)) {\n    const value = newProps[key];\n\n    if (value) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props[key] = value;\n    } else {\n      delete props[key];\n    }\n  }\n}\n/**\r\n * Sets or updates Tabster attribute of the element.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param newProps new Tabster props to set.\r\n * @param update if true, newProps will be merged with the existing props.\r\n *  When true and the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction setTabsterAttribute(element, newProps, update) {\n  let props;\n\n  if (update) {\n    const attr = element.getAttribute(TABSTER_ATTRIBUTE_NAME);\n\n    if (attr) {\n      try {\n        props = JSON.parse(attr);\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    }\n  }\n\n  if (!props) {\n    props = {};\n  }\n\n  mergeTabsterProps(props, newProps);\n\n  if (Object.keys(props).length > 0) {\n    element.setAttribute(TABSTER_ATTRIBUTE_NAME, getTabsterAttribute(props, true));\n  } else {\n    element.removeAttribute(TABSTER_ATTRIBUTE_NAME);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nfunction _setInformativeStyle$3(weakElement, remove, id) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-root\");\n      } else {\n        element.style.setProperty(\"--tabster-root\", id + \",\");\n      }\n    }\n  }\n}\n\nclass RootDummyManager extends DummyInputManager {\n  constructor(tabster, element, setFocused, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Root, sys, undefined, true);\n\n    this._onDummyInputFocus = dummyInput => {\n      var _a;\n\n      if (dummyInput.useDefaultAction) {\n        // When we've reached the last focusable element, we want to let the browser\n        // to move the focus outside of the page. In order to do that we're synchronously\n        // calling focus() of the dummy input from the Tab key handler and allowing\n        // the default action to move the focus out.\n        this._setFocused(false);\n      } else {\n        // The only way a dummy input gets focused is during the keyboard navigation.\n        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n        const element = this._element.get();\n\n        if (element) {\n          this._setFocused(true);\n\n          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {\n            container: element,\n            ignoreAccessibility: true\n          });\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n            return;\n          }\n        }\n\n        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();\n      }\n    };\n\n    this._setHandlers(this._onDummyInputFocus);\n\n    this._tabster = tabster;\n    this._setFocused = setFocused;\n  }\n\n}\n\nclass Root extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._isFocused = false;\n\n    this._setFocused = hasFocused => {\n      var _a;\n\n      if (this._setFocusedTimer) {\n        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n\n        delete this._setFocusedTimer;\n      }\n\n      if (this._isFocused === hasFocused) {\n        return;\n      }\n\n      const element = this._element.get();\n\n      if (element) {\n        if (hasFocused) {\n          this._isFocused = true;\n          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);\n          element.dispatchEvent(new RootFocusEvent({\n            element\n          }));\n        } else {\n          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {\n            var _a;\n\n            delete this._setFocusedTimer;\n            this._isFocused = false;\n            (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(true);\n            element.dispatchEvent(new RootBlurEvent({\n              element\n            }));\n          }, 0);\n        }\n      }\n    };\n\n    this._onFocusIn = event => {\n      const getParent = this._tabster.getParent;\n\n      const rootElement = this._element.get();\n\n      let curElement = event.composedPath()[0];\n\n      do {\n        if (curElement === rootElement) {\n          this._setFocused(true);\n\n          return;\n        }\n\n        curElement = curElement && getParent(curElement);\n      } while (curElement);\n    };\n\n    this._onFocusOut = () => {\n      this._setFocused(false);\n    };\n\n    this._onDispose = onDispose;\n    const win = tabster.getWindow;\n    this.uid = getElementUId(win, element);\n    this._sys = sys;\n\n    if (tabster.controlTab || tabster.rootDummyInputs) {\n      this.addDummyInputs();\n    }\n\n    const w = win();\n    const doc = w.document;\n    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn);\n    doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);\n\n    this._add();\n  }\n\n  addDummyInputs() {\n    if (!this._dummyManager) {\n      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    const win = this._tabster.getWindow();\n\n    const doc = win.document;\n    doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn);\n    doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);\n\n    if (this._setFocusedTimer) {\n      win.clearTimeout(this._setFocusedTimer);\n      delete this._setFocusedTimer;\n    }\n\n    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n\n    this._remove();\n  }\n\n  moveOutWithDefaultAction(isBackward, relatedEvent) {\n    const dummyManager = this._dummyManager;\n\n    if (dummyManager) {\n      dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);\n    } else {\n      const el = this.getElement();\n\n      if (el) {\n        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward, relatedEvent);\n      }\n    }\n  }\n\n  _add() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, false, this.uid);\n    }\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass RootAPI {\n  constructor(tabster, autoRoot) {\n    this._autoRootWaiting = false;\n    this._roots = {};\n    this._forceDummy = false;\n    this.rootById = {};\n\n    this._autoRootCreate = () => {\n      var _a;\n\n      const doc = this._win().document;\n\n      const body = doc.body;\n\n      if (body) {\n        this._autoRootUnwait(doc);\n\n        const props = this._autoRoot;\n\n        if (props) {\n          setTabsterAttribute(body, {\n            root: props\n          }, true);\n          updateTabsterByAttribute(this._tabster, body);\n          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;\n        }\n      } else if (!this._autoRootWaiting) {\n        this._autoRootWaiting = true;\n        doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n      }\n\n      return undefined;\n    };\n\n    this._onRootDispose = root => {\n      delete this._roots[root.id];\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._autoRoot = autoRoot;\n    tabster.queueInit(() => {\n      if (this._autoRoot) {\n        this._autoRootCreate();\n      }\n    });\n  }\n\n  _autoRootUnwait(doc) {\n    doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n    this._autoRootWaiting = false;\n  }\n\n  dispose() {\n    const win = this._win();\n\n    this._autoRootUnwait(win.document);\n\n    delete this._autoRoot;\n    Object.keys(this._roots).forEach(rootId => {\n      if (this._roots[rootId]) {\n        this._roots[rootId].dispose();\n\n        delete this._roots[rootId];\n      }\n    });\n    this.rootById = {};\n  }\n\n  createRoot(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);\n    this._roots[newRoot.id] = newRoot;\n\n    if (this._forceDummy) {\n      newRoot.addDummyInputs();\n    }\n\n    return newRoot;\n  }\n\n  addDummyInputs() {\n    this._forceDummy = true;\n    const roots = this._roots;\n\n    for (const id of Object.keys(roots)) {\n      roots[id].addDummyInputs();\n    }\n  }\n\n  static getRootByUId(getWindow, id) {\n    const tabster = getWindow().__tabsterInstance;\n\n    return tabster && tabster.root.rootById[id];\n  }\n  /**\r\n   * Fetches the tabster context for an element walking up its ancestors\r\n   *\r\n   * @param tabster Tabster instance\r\n   * @param element The element the tabster context should represent\r\n   * @param options Additional options\r\n   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\r\n   */\n\n\n  static getTabsterContext(tabster, element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _a, _b, _c, _d;\n\n    if (!element.ownerDocument) {\n      return undefined;\n    }\n\n    const {\n      checkRtl,\n      referenceElement\n    } = options;\n    const getParent = tabster.getParent; // Normally, the initialization starts on the next tick after the tabster\n    // instance creation. However, if the application starts using it before\n    // the next tick, we need to make sure the initialization is done.\n\n    tabster.drainInitQueue();\n    let root;\n    let modalizer;\n    let groupper;\n    let mover;\n    let excludedFromMover = false;\n    let groupperBeforeMover;\n    let modalizerInGroupper;\n    let dirRightToLeft;\n    let uncontrolled;\n    let curElement = referenceElement || element;\n    const ignoreKeydown = {};\n\n    while (curElement && (!root || checkRtl)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, curElement);\n\n      if (checkRtl && dirRightToLeft === undefined) {\n        const dir = curElement.dir;\n\n        if (dir) {\n          dirRightToLeft = dir.toLowerCase() === \"rtl\";\n        }\n      }\n\n      if (!tabsterOnElement) {\n        curElement = getParent(curElement);\n        continue;\n      }\n\n      const tagName = curElement.tagName;\n\n      if (tabsterOnElement.uncontrolled || tagName === \"IFRAME\" || tagName === \"WEBVIEW\") {\n        uncontrolled = curElement;\n      }\n\n      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {\n        excludedFromMover = true;\n      }\n\n      const curModalizer = tabsterOnElement.modalizer;\n      const curGroupper = tabsterOnElement.groupper;\n      const curMover = tabsterOnElement.mover;\n\n      if (!modalizer && curModalizer) {\n        modalizer = curModalizer;\n      }\n\n      if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n        if (modalizer) {\n          // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n            modalizer = undefined;\n            groupper = curGroupper;\n          }\n\n          modalizerInGroupper = curGroupper;\n        } else {\n          groupper = curGroupper;\n        }\n      }\n\n      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element) && curElement.contains(element) // Mover makes sense only for really inside elements, not for virutal out of the DOM order children.\n      ) {\n        mover = curMover;\n        groupperBeforeMover = !!groupper && groupper !== curGroupper;\n      }\n\n      if (tabsterOnElement.root) {\n        root = tabsterOnElement.root;\n      }\n\n      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {\n        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);\n      }\n\n      curElement = getParent(curElement);\n    } // No root element could be found, try to get an auto root\n\n\n    if (!root) {\n      const rootAPI = tabster.root;\n      const autoRoot = rootAPI._autoRoot;\n\n      if (autoRoot) {\n        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {\n          root = rootAPI._autoRootCreate();\n        }\n      }\n    }\n\n    if (groupper && !mover) {\n      groupperBeforeMover = true;\n    }\n\n    if (process.env.NODE_ENV === 'development' && !root) {\n      if (modalizer || groupper || mover) {\n        console.error(\"Tabster Root is required for Mover, Groupper and Modalizer to work.\");\n      }\n    }\n\n    const shouldIgnoreKeydown = event => !!ignoreKeydown[event.key];\n\n    return root ? {\n      root,\n      modalizer,\n      groupper,\n      mover,\n      groupperBeforeMover,\n      modalizerInGroupper,\n      rtl: checkRtl ? !!dirRightToLeft : undefined,\n      uncontrolled,\n      excludedFromMover,\n      ignoreKeydown: shouldIgnoreKeydown\n    } : undefined;\n  }\n\n  static getRoot(tabster, element) {\n    var _a;\n\n    const getParent = tabster.getParent;\n\n    for (let el = element; el; el = getParent(el)) {\n      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;\n\n      if (root) {\n        return root;\n      }\n    }\n\n    return undefined;\n  }\n\n  onRoot(root, removed) {\n    if (removed) {\n      delete this.rootById[root.uid];\n    } else {\n      this.rootById[root.uid] = root;\n    }\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _containerHistoryLength = 10;\nclass DeloserItemBase {}\nclass DeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser) {\n    super();\n    this.uid = deloser.uid;\n    this._tabster = tabster;\n    this._deloser = deloser;\n  }\n\n  belongsTo(deloser) {\n    return deloser === this._deloser;\n  }\n\n  unshift(element) {\n    this._deloser.unshift(element);\n  }\n\n  async focusAvailable() {\n    const available = this._deloser.findAvailable();\n\n    const deloserElement = this._deloser.getElement();\n\n    if (available && deloserElement) {\n      if (!deloserElement.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"deloser\",\n        owner: deloserElement,\n        next: available\n      }))) {\n        // Default action is prevented, don't look further.\n        return null;\n      }\n\n      return this._tabster.focusedElement.focus(available);\n    }\n\n    return false;\n  }\n\n  async resetFocus() {\n    const getWindow = this._tabster.getWindow;\n    return getPromise(getWindow).resolve(this._deloser.resetFocus());\n  }\n\n}\nclass DeloserHistoryByRootBase {\n  constructor(tabster, rootUId) {\n    this._history = [];\n    this._tabster = tabster;\n    this.rootUId = rootUId;\n  }\n\n  getLength() {\n    return this._history.length;\n  }\n\n  removeDeloser(deloser) {\n    this._history = this._history.filter(c => !c.belongsTo(deloser));\n  }\n\n  hasDeloser(deloser) {\n    return this._history.some(d => d.belongsTo(deloser));\n  }\n\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  unshiftToDeloser(deloser, element) {\n    let item;\n\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!item) {\n      item = new DeloserItem(this._tabster, deloser);\n    }\n\n    item.unshift(element);\n\n    this._history.unshift(item);\n\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n  }\n\n  async focusAvailable(from) {\n    let skip = !!from;\n\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n\n      if (!skip) {\n        const result = await i.focusAvailable(); // Result is null when the default action is prevented by the application\n        // and we don't need to look further.\n\n        if (result || result === null) {\n          return result;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus(from) {\n    let skip = !!from;\n    const resetQueue = {};\n\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n\n      if (!skip && !resetQueue[i.uid]) {\n        resetQueue[i.uid] = i;\n      }\n    } // Nothing is found, at least try to reset.\n\n\n    for (const id of Object.keys(resetQueue)) {\n      if (await resetQueue[id].resetFocus()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass DeloserHistory {\n  constructor(tabster) {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    this._history = [];\n    this._tabster = tabster;\n  }\n\n  dispose() {\n    this._history = [];\n  }\n\n  process(element) {\n    var _a;\n\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    const rootUId = ctx && ctx.root.uid;\n    const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n    if (!rootUId || !deloser) {\n      return undefined;\n    }\n\n    const historyByRoot = this.make(rootUId, () => new DeloserHistoryByRoot(this._tabster, rootUId));\n\n    if (!ctx || !ctx.modalizer || ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.isActive())) {\n      historyByRoot.unshiftToDeloser(deloser, element);\n    }\n\n    return deloser;\n  }\n\n  make(rootUId, createInstance) {\n    let historyByRoot;\n\n    for (let i = 0; i < this._history.length; i++) {\n      const hbr = this._history[i];\n\n      if (hbr.rootUId === rootUId) {\n        historyByRoot = hbr;\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!historyByRoot) {\n      historyByRoot = createInstance();\n    }\n\n    this._history.unshift(historyByRoot);\n\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n\n    return historyByRoot;\n  }\n\n  removeDeloser(deloser) {\n    this._history.forEach(i => {\n      i.removeDeloser(deloser);\n    });\n\n    this._history = this._history.filter(i => i.getLength() > 0);\n  }\n\n  async focusAvailable(from) {\n    let skip = !!from;\n\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n\n      if (!skip) {\n        const result = await h.focusAvailable(from); // Result is null when the default action is prevented by the application\n        // and we don't need to look further.\n\n        if (result || result === null) {\n          return result;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus(from) {\n    let skip = !!from;\n\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await h.resetFocus(from))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction _setInformativeStyle$2(weakElement, remove, isActive, snapshotIndex) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-deloser\");\n      } else {\n        element.style.setProperty(\"--tabster-deloser\", (isActive ? \"active\" : \"inactive\") + \",\" + (\"snapshot-\" + snapshotIndex));\n      }\n    }\n  }\n}\n\nfunction buildElementSelector(element, withClass, withIndex) {\n  const selector = [];\n  const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n  const escapeReplaceValue = \"\\\\$1\";\n  const elementId = element.getAttribute(\"id\");\n\n  if (elementId) {\n    selector.push(\"#\" + elementId.replace(escapeRegExp, escapeReplaceValue));\n  }\n\n  if (withClass !== false && element.className) {\n    element.className.split(\" \").forEach(cls => {\n      cls = cls.trim();\n\n      if (cls) {\n        selector.push(\".\" + cls.replace(escapeRegExp, escapeReplaceValue));\n      }\n    });\n  }\n\n  let index = 0;\n  let el;\n\n  if (withIndex !== false && selector.length === 0) {\n    el = element;\n\n    while (el) {\n      index++;\n      el = el.previousElementSibling;\n    }\n\n    selector.unshift(\":nth-child(\" + index + \")\");\n  }\n\n  selector.unshift(element.tagName.toLowerCase());\n  return selector.join(\"\");\n}\n\nfunction buildSelector(element) {\n  if (!documentContains(element.ownerDocument, element)) {\n    return undefined;\n  }\n\n  const selector = [buildElementSelector(element)];\n  let node = dom.getParentNode(element);\n\n  while (node && node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n    // Stop at the shadow root as cross shadow selectors won't work.\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const isBody = node.tagName === \"BODY\";\n      selector.unshift(buildElementSelector(node, false, !isBody));\n\n      if (isBody) {\n        break;\n      }\n    }\n\n    node = dom.getParentNode(node);\n  }\n\n  return selector.join(\" \");\n}\n\nclass Deloser extends TabsterPart {\n  constructor(tabster, element, onDispose, props) {\n    super(tabster, element, props);\n    this._isActive = false;\n    this._history = [[]];\n    this._snapshotIndex = 0;\n\n    this.isActive = () => {\n      return this._isActive;\n    };\n\n    this.setSnapshot = index => {\n      this._snapshotIndex = index;\n\n      if (this._history.length > index + 1) {\n        this._history.splice(index + 1, this._history.length - index - 1);\n      }\n\n      if (!this._history[index]) {\n        this._history[index] = [];\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n      }\n    };\n\n    this.focusFirst = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.focusFirst({\n        container: e\n      });\n    };\n\n    this.focusDefault = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    this.resetFocus = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    this.clearHistory = preserveExisting => {\n      const element = this._element.get();\n\n      if (!element) {\n        this._history[this._snapshotIndex] = [];\n        return;\n      }\n\n      this._history[this._snapshotIndex] = this._history[this._snapshotIndex].filter(we => {\n        const e = we.get();\n        return e && preserveExisting ? dom.nodeContains(element, e) : false;\n      });\n    };\n\n    this.uid = getElementUId(tabster.getWindow, element);\n    this.strategy = props.strategy || DeloserStrategies.Auto;\n    this._onDispose = onDispose;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n\n  dispose() {\n    this._remove();\n\n    this._onDispose(this);\n\n    this._isActive = false;\n    this._snapshotIndex = 0;\n    this._props = {};\n    this._history = [];\n  }\n\n  setActive(active) {\n    this._isActive = active;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n\n  getActions() {\n    return {\n      focusDefault: this.focusDefault,\n      focusFirst: this.focusFirst,\n      resetFocus: this.resetFocus,\n      clearHistory: this.clearHistory,\n      setSnapshot: this.setSnapshot,\n      isActive: this.isActive\n    };\n  }\n\n  unshift(element) {\n    let cur = this._history[this._snapshotIndex];\n    cur = this._history[this._snapshotIndex] = cur.filter(we => {\n      const e = we.get();\n      return e && e !== element;\n    });\n    cur.unshift(new WeakHTMLElement(this._tabster.getWindow, element, buildSelector(element)));\n\n    while (cur.length > _containerHistoryLength) {\n      cur.pop();\n    }\n  }\n\n  findAvailable() {\n    const element = this._element.get();\n\n    if (!element || !this._tabster.focusable.isVisible(element)) {\n      return null;\n    }\n\n    let restoreFocusOrder = this._props.restoreFocusOrder;\n    let available = null;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n    if (!ctx) {\n      return null;\n    }\n\n    const root = ctx.root;\n    const rootElement = root.getElement();\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (restoreFocusOrder === undefined) {\n      restoreFocusOrder = root.getProps().restoreFocusOrder;\n    }\n\n    if (restoreFocusOrder === RestoreFocusOrders.RootDefault) {\n      available = this._tabster.focusable.findDefault({\n        container: rootElement\n      });\n    }\n\n    if (!available && restoreFocusOrder === RestoreFocusOrders.RootFirst) {\n      available = this._findFirst(rootElement);\n    }\n\n    if (available) {\n      return available;\n    }\n\n    const availableInHistory = this._findInHistory();\n\n    if (availableInHistory && restoreFocusOrder === RestoreFocusOrders.History) {\n      return availableInHistory;\n    }\n\n    const availableDefault = this._tabster.focusable.findDefault({\n      container: element\n    });\n\n    if (availableDefault && restoreFocusOrder === RestoreFocusOrders.DeloserDefault) {\n      return availableDefault;\n    }\n\n    const availableFirst = this._findFirst(element);\n\n    if (availableFirst && restoreFocusOrder === RestoreFocusOrders.DeloserFirst) {\n      return availableFirst;\n    }\n\n    return availableDefault || availableInHistory || availableFirst || null;\n  }\n\n  customFocusLostHandler(element) {\n    return element.dispatchEvent(new DeloserFocusLostEvent(this.getActions()));\n  }\n\n  _findInHistory() {\n    const cur = this._history[this._snapshotIndex].slice(0);\n\n    this.clearHistory(true);\n\n    for (let i = 0; i < cur.length; i++) {\n      const we = cur[i];\n      const e = we.get();\n\n      const element = this._element.get();\n\n      if (e && element && dom.nodeContains(element, e)) {\n        if (this._tabster.focusable.isFocusable(e)) {\n          return e;\n        }\n      } else if (!this._props.noSelectorCheck) {\n        // Element is not in the DOM, try to locate the node by it's\n        // selector. This might return not exactly the right node,\n        // but it would be easily fixable by having more detailed selectors.\n        const selector = we.getData();\n\n        if (selector && element) {\n          let els;\n\n          try {\n            els = dom.querySelectorAll(element.ownerDocument, selector);\n          } catch (e) {\n            if (process.env.NODE_ENV === 'development') {\n              // This should never happen, unless there is some bug in buildElementSelector().\n              console.error(`Failed to querySelectorAll('${selector}')`);\n            }\n\n            continue;\n          }\n\n          for (let i = 0; i < els.length; i++) {\n            const el = els[i];\n\n            if (el && this._tabster.focusable.isFocusable(el)) {\n              return el;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _findFirst(element) {\n    if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      const first = this._tabster.focusable.findFirst({\n        container: element,\n        useActiveModalizer: true\n      });\n\n      if (first) {\n        return first;\n      }\n    }\n\n    return null;\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass DeloserAPI {\n  constructor(tabster, props) {\n    /**\r\n     * Tracks if focus is inside a deloser\r\n     */\n    this._inDeloser = false;\n    this._isRestoringFocus = false;\n    this._isPaused = false;\n\n    this._onRestoreFocus = event => {\n      var _a;\n\n      const target = event.composedPath()[0];\n\n      if (target) {\n        const available = (_a = DeloserAPI.getDeloser(this._tabster, target)) === null || _a === void 0 ? void 0 : _a.findAvailable();\n\n        if (available) {\n          this._tabster.focusedElement.focus(available);\n        }\n\n        event.stopImmediatePropagation();\n      }\n    };\n\n    this._onFocus = e => {\n      if (this._restoreFocusTimer) {\n        this._win().clearTimeout(this._restoreFocusTimer);\n\n        this._restoreFocusTimer = undefined;\n      }\n\n      if (!e) {\n        this._scheduleRestoreFocus();\n\n        return;\n      }\n\n      const deloser = this._history.process(e);\n\n      if (deloser) {\n        this._activate(deloser);\n      } else {\n        this._deactivate();\n      }\n    };\n\n    this._onDeloserDispose = deloser => {\n      this._history.removeDeloser(deloser);\n\n      if (deloser.isActive()) {\n        this._scheduleRestoreFocus();\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._history = new DeloserHistory(tabster);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n\n      const doc = this._win().document;\n\n      doc.addEventListener(DeloserRestoreFocusEventName, this._onRestoreFocus);\n      const activeElement = dom.getActiveElement(doc);\n\n      if (activeElement && activeElement !== doc.body) {\n        // Adding currently focused element to the deloser history.\n        this._onFocus(activeElement);\n      }\n    });\n    const autoDeloser = props === null || props === void 0 ? void 0 : props.autoDeloser;\n\n    if (autoDeloser) {\n      this._autoDeloser = autoDeloser;\n    }\n  }\n\n  dispose() {\n    const win = this._win();\n\n    if (this._restoreFocusTimer) {\n      win.clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n\n    if (this._autoDeloserInstance) {\n      this._autoDeloserInstance.dispose();\n\n      delete this._autoDeloserInstance;\n      delete this._autoDeloser;\n    }\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    win.document.removeEventListener(DeloserRestoreFocusEventName, this._onRestoreFocus);\n\n    this._history.dispose();\n\n    delete this._curDeloser;\n  }\n\n  createDeloser(element, props) {\n    var _a;\n\n    if (process.env.NODE_ENV === 'development') ;\n\n    const deloser = new Deloser(this._tabster, element, this._onDeloserDispose, props);\n\n    if (dom.nodeContains(element, (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      this._activate(deloser);\n    }\n\n    return deloser;\n  }\n\n  getActions(element) {\n    for (let e = element; e; e = dom.getParentElement(e)) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n      if (tabsterOnElement && tabsterOnElement.deloser) {\n        return tabsterOnElement.deloser.getActions();\n      }\n    }\n\n    return undefined;\n  }\n\n  pause() {\n    this._isPaused = true;\n\n    if (this._restoreFocusTimer) {\n      this._win().clearTimeout(this._restoreFocusTimer);\n\n      this._restoreFocusTimer = undefined;\n    }\n  }\n\n  resume(restore) {\n    this._isPaused = false;\n\n    if (restore) {\n      this._scheduleRestoreFocus();\n    }\n  }\n  /**\r\n   * Activates and sets the current deloser\r\n   */\n\n\n  _activate(deloser) {\n    const curDeloser = this._curDeloser;\n\n    if (curDeloser !== deloser) {\n      this._inDeloser = true;\n      curDeloser === null || curDeloser === void 0 ? void 0 : curDeloser.setActive(false);\n      deloser.setActive(true);\n      this._curDeloser = deloser;\n    }\n  }\n  /**\r\n   * Called when focus should no longer be in a deloser\r\n   */\n\n\n  _deactivate() {\n    var _a;\n\n    this._inDeloser = false;\n    (_a = this._curDeloser) === null || _a === void 0 ? void 0 : _a.setActive(false);\n    this._curDeloser = undefined;\n  }\n\n  _scheduleRestoreFocus(force) {\n    if (this._isPaused || this._isRestoringFocus) {\n      return;\n    }\n\n    const restoreFocus = async () => {\n      this._restoreFocusTimer = undefined;\n\n      const lastFocused = this._tabster.focusedElement.getLastFocusedElement();\n\n      if (!force && (this._isRestoringFocus || !this._inDeloser || lastFocused && !isDisplayNone(lastFocused))) {\n        return;\n      }\n\n      const curDeloser = this._curDeloser;\n      let isManual = false;\n\n      if (curDeloser) {\n        if (lastFocused && curDeloser.customFocusLostHandler(lastFocused)) {\n          return;\n        }\n\n        if (curDeloser.strategy === DeloserStrategies.Manual) {\n          isManual = true;\n        } else {\n          const curDeloserElement = curDeloser.getElement();\n          const el = curDeloser.findAvailable();\n\n          if (el && (!(curDeloserElement === null || curDeloserElement === void 0 ? void 0 : curDeloserElement.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"deloser\",\n            owner: curDeloserElement,\n            next: el\n          }))) || this._tabster.focusedElement.focus(el))) {\n            return;\n          }\n        }\n      }\n\n      this._deactivate();\n\n      if (isManual) {\n        return;\n      }\n\n      this._isRestoringFocus = true; // focusAvailable returns null when the default action is prevented by the application, false\n      // when nothing was focused and true when something was focused.\n\n      if ((await this._history.focusAvailable(null)) === false) {\n        await this._history.resetFocus(null);\n      }\n\n      this._isRestoringFocus = false;\n    };\n\n    if (force) {\n      restoreFocus();\n    } else {\n      this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n    }\n  }\n\n  static getDeloser(tabster, element) {\n    var _a;\n\n    let root;\n\n    for (let e = element; e; e = dom.getParentElement(e)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n      if (tabsterOnElement) {\n        if (!root) {\n          root = tabsterOnElement.root;\n        }\n\n        const deloser = tabsterOnElement.deloser;\n\n        if (deloser) {\n          return deloser;\n        }\n      }\n    }\n\n    const deloserAPI = tabster.deloser && tabster.deloser;\n\n    if (deloserAPI) {\n      if (deloserAPI._autoDeloserInstance) {\n        return deloserAPI._autoDeloserInstance;\n      }\n\n      const autoDeloserProps = deloserAPI._autoDeloser;\n\n      if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n        const body = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;\n\n        if (body) {\n          deloserAPI._autoDeloserInstance = new Deloser(tabster, body, tabster.deloser._onDeloserDispose, autoDeloserProps);\n        }\n      }\n\n      return deloserAPI._autoDeloserInstance;\n    }\n\n    return undefined;\n  }\n\n  static getHistory(instance) {\n    return instance._history;\n  }\n\n  static forceRestoreFocus(instance) {\n    instance._scheduleRestoreFocus(true);\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass Subscribable {\n  constructor() {\n    this._callbacks = [];\n  }\n\n  dispose() {\n    this._callbacks = [];\n    delete this._val;\n  }\n\n  subscribe(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n\n    if (index < 0) {\n      callbacks.push(callback);\n    }\n  }\n\n  subscribeFirst(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n\n    if (index >= 0) {\n      callbacks.splice(index, 1);\n    }\n\n    callbacks.unshift(callback);\n  }\n\n  unsubscribe(callback) {\n    const index = this._callbacks.indexOf(callback);\n\n    if (index >= 0) {\n      this._callbacks.splice(index, 1);\n    }\n  }\n\n  setVal(val, detail) {\n    if (this._val === val) {\n      return;\n    }\n\n    this._val = val;\n\n    this._callCallbacks(val, detail);\n  }\n\n  getVal() {\n    return this._val;\n  }\n\n  trigger(val, detail) {\n    this._callCallbacks(val, detail);\n  }\n\n  _callCallbacks(val, detail) {\n    this._callbacks.forEach(callback => callback(val, detail));\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\nconst _targetIdUp = \"up\";\nconst CrossOriginTransactionTypes = {\n  Bootstrap: 1,\n  FocusElement: 2,\n  State: 3,\n  GetElement: 4,\n  RestoreFocusInDeloser: 5,\n  Ping: 6\n};\n\nclass CrossOriginDeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser, trasactions) {\n    super();\n    this._deloser = deloser;\n    this._transactions = trasactions;\n  }\n\n  belongsTo(deloser) {\n    return deloser.deloserUId === this._deloser.deloserUId;\n  }\n\n  async focusAvailable() {\n    const data = { ...this._deloser,\n      reset: false\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n\n  async resetFocus() {\n    const data = { ...this._deloser,\n      reset: true\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  constructor(tabster, rootUId, transactions) {\n    super(tabster, rootUId);\n    this._transactions = transactions;\n  }\n\n  unshift(deloser) {\n    let item;\n\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!item) {\n      item = new CrossOriginDeloserItem(this._tabster, deloser, this._transactions);\n    }\n\n    this._history.unshift(item);\n\n    this._history.splice(10, this._history.length - 10);\n  }\n\n  async focusAvailable() {\n    for (const i of this._history) {\n      if (await i.focusAvailable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus() {\n    for (const i of this._history) {\n      if (await i.resetFocus()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass CrossOriginTransaction {\n  constructor(tabster, getOwner, knownTargets, value, timeout, sentTo, targetId, sendUp) {\n    this._inProgress = {};\n    this._isDone = false;\n    this._isSelfResponding = false;\n    this._sentCount = 0;\n    this.tabster = tabster;\n    this.owner = getOwner;\n    this.ownerId = getWindowUId(getOwner());\n    this.id = getUId(getOwner());\n    this.beginData = value;\n    this._knownTargets = knownTargets;\n    this._sentTo = sentTo || {\n      [this.ownerId]: true\n    };\n    this.targetId = targetId;\n    this.sendUp = sendUp;\n    this.timeout = timeout;\n    this._promise = new (getPromise(getOwner))((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  getTargets(knownTargets) {\n    return this.targetId === _targetIdUp ? this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : null : this.targetId ? knownTargets[this.targetId] ? {\n      [this.targetId]: {\n        send: knownTargets[this.targetId].send\n      }\n    } : null : Object.keys(knownTargets).length === 0 && this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : Object.keys(knownTargets).length > 0 ? knownTargets : null;\n  }\n\n  begin(selfResponse) {\n    const targets = this.getTargets(this._knownTargets);\n    const sentTo = { ...this._sentTo\n    };\n\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        sentTo[id] = true;\n      }\n    }\n\n    const data = {\n      transaction: this.id,\n      type: this.type,\n      isResponse: false,\n      timestamp: Date.now(),\n      owner: this.ownerId,\n      sentto: sentTo,\n      timeout: this.timeout,\n      beginData: this.beginData\n    };\n\n    if (this.targetId) {\n      data.target = this.targetId;\n    }\n\n    if (selfResponse) {\n      this._isSelfResponding = true;\n      selfResponse(data).then(value => {\n        this._isSelfResponding = false;\n\n        if (value !== undefined) {\n          if (!this.endData) {\n            this.endData = value;\n          }\n        }\n\n        if (this.endData || this._sentCount === 0) {\n          this.end();\n        }\n      });\n    }\n\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        if (!(id in this._sentTo)) {\n          this._send(targets[id].send, id, data);\n        }\n      }\n    }\n\n    if (this._sentCount === 0 && !this._isSelfResponding) {\n      this.end();\n    }\n\n    return this._promise;\n  }\n\n  _send(send, targetId, data) {\n    if (this._inProgress[targetId] === undefined) {\n      this._inProgress[targetId] = true;\n      this._sentCount++;\n      send(data);\n    }\n  }\n\n  end(error) {\n    if (this._isDone) {\n      return;\n    }\n\n    this._isDone = true;\n\n    if (this.endData === undefined && error) {\n      if (this._reject) {\n        this._reject(error);\n      }\n    } else if (this._resolve) {\n      this._resolve(this.endData);\n    }\n  }\n\n  onResponse(data) {\n    const endData = data.endData;\n\n    if (endData !== undefined && !this.endData) {\n      this.endData = endData;\n    }\n\n    const inProgressId = data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n    if (this._inProgress[inProgressId]) {\n      this._inProgress[inProgressId] = false;\n      this._sentCount--;\n\n      if (this.endData || this._sentCount === 0 && !this._isSelfResponding) {\n        this.end();\n      }\n    }\n  }\n\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Bootstrap;\n  }\n\n  static shouldForward() {\n    return false;\n  }\n\n  static async makeResponse(tabster) {\n    return {\n      isNavigatingWithKeyboard: tabster.keyboardNavigation.isNavigatingWithKeyboard()\n    };\n  }\n\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.FocusElement;\n  }\n\n  static shouldSelfRespond() {\n    return true;\n  }\n\n  static shouldForward(tabster, data, getOwner) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !el || !tabster.focusable.isFocusable(el);\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !!el && tabster.focusedElement.focus(el, true) || !!(await forwardResult);\n  }\n\n}\n\nconst CrossOriginStates = {\n  Focused: 1,\n  Blurred: 2,\n  Observed: 3,\n  DeadWindow: 4,\n  KeyboardNavigation: 5,\n  Outline: 6\n};\n\nclass StateTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.State;\n  }\n\n  static shouldSelfRespond(tabster, data) {\n    return data.state !== CrossOriginStates.DeadWindow && data.state !== CrossOriginStates.KeyboardNavigation;\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult, isSelfResponse) {\n    const timestamp = data.timestamp;\n    const beginData = data.beginData;\n\n    if (timestamp && beginData) {\n      switch (beginData.state) {\n        case CrossOriginStates.Focused:\n          return StateTransaction._makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse);\n\n        case CrossOriginStates.Blurred:\n          return StateTransaction._makeBlurredResponse(tabster, timestamp, beginData, transactions.ctx);\n\n        case CrossOriginStates.Observed:\n          return StateTransaction._makeObservedResponse(tabster, beginData);\n\n        case CrossOriginStates.DeadWindow:\n          return StateTransaction._makeDeadWindowResponse(tabster, beginData, transactions, forwardResult);\n\n        case CrossOriginStates.KeyboardNavigation:\n          return StateTransaction._makeKeyboardNavigationResponse(tabster, transactions.ctx, beginData.isNavigatingWithKeyboard);\n\n        case CrossOriginStates.Outline:\n          return StateTransaction._makeOutlineResponse(tabster, transactions.ctx, beginData.outline);\n      }\n    }\n\n    return true;\n  }\n\n  static createElement(tabster, beginData) {\n    return beginData.uid ? new CrossOriginElement(tabster, beginData.uid, beginData.ownerUId, beginData.id, beginData.rootUId, beginData.observedName, beginData.observedDetails) : null;\n  }\n\n  static async _makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse) {\n    const element = StateTransaction.createElement(tabster, beginData);\n\n    if (beginData && beginData.ownerUId && element) {\n      transactions.ctx.focusOwner = beginData.ownerUId;\n      transactions.ctx.focusOwnerTimestamp = timestamp;\n\n      if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n        const deloserAPI = tabster.deloser;\n\n        if (deloserAPI) {\n          const history = DeloserAPI.getHistory(deloserAPI);\n          const deloser = {\n            ownerUId: beginData.ownerUId,\n            deloserUId: beginData.deloserUId,\n            rootUId: beginData.rootUId\n          };\n          const historyItem = history.make(beginData.rootUId, () => new CrossOriginDeloserHistoryByRoot(tabster, deloser.rootUId, transactions));\n          historyItem.unshift(deloser);\n        }\n      }\n\n      CrossOriginFocusedElementState.setVal( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, element, {\n        isFocusedProgrammatically: beginData.isFocusedProgrammatically\n      });\n    }\n\n    return true;\n  }\n\n  static async _makeBlurredResponse(tabster, timestamp, beginData, context) {\n    if (beginData && (beginData.ownerUId === context.focusOwner || beginData.force) && (!context.focusOwnerTimestamp || context.focusOwnerTimestamp < timestamp)) {\n      CrossOriginFocusedElementState.setVal( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, undefined, {});\n    }\n\n    return true;\n  }\n\n  static async _makeObservedResponse(tabster, beginData) {\n    const name = beginData.observedName;\n    const element = StateTransaction.createElement(tabster, beginData);\n\n    if (name && element) {\n      CrossOriginObservedElementState.trigger( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.observedElement, element, {\n        names: [name],\n        details: beginData.observedDetails\n      });\n    }\n\n    return true;\n  }\n\n  static async _makeDeadWindowResponse(tabster, beginData, transactions, forwardResult) {\n    const deadUId = beginData && beginData.ownerUId;\n\n    if (deadUId) {\n      transactions.removeTarget(deadUId);\n    }\n\n    return forwardResult.then(() => {\n      if (deadUId === transactions.ctx.focusOwner) {\n        const deloserAPI = tabster.deloser;\n\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n\n      return true;\n    });\n  }\n\n  static async _makeKeyboardNavigationResponse(tabster, context, isNavigatingWithKeyboard) {\n    if (isNavigatingWithKeyboard !== undefined && tabster.keyboardNavigation.isNavigatingWithKeyboard() !== isNavigatingWithKeyboard) {\n      context.ignoreKeyboardNavigationStateUpdate = true;\n      tabster.keyboardNavigation.setNavigatingWithKeyboard(isNavigatingWithKeyboard);\n      context.ignoreKeyboardNavigationStateUpdate = false;\n    }\n\n    return true;\n  }\n\n  static async _makeOutlineResponse(tabster, context, props) {\n    if (context.origOutlineSetup) {\n      context.origOutlineSetup.call( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.outline, props);\n    }\n\n    return true;\n  }\n\n}\n\nclass GetElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.GetElement;\n  }\n\n  static shouldSelfRespond() {\n    return true;\n  }\n\n  static findElement(tabster, getOwner, data) {\n    let element;\n\n    if (data && (!data.ownerId || data.ownerId === getWindowUId(getOwner()))) {\n      if (data.id) {\n        element = dom.getElementById(getOwner().document, data.id);\n\n        if (element && data.rootId) {\n          const ctx = RootAPI.getTabsterContext(tabster, element);\n\n          if (!ctx || ctx.root.uid !== data.rootId) {\n            return null;\n          }\n        }\n      } else if (data.uid) {\n        const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n        element = ref && ref.get();\n      } else if (data.observedName) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        element = tabster.observedElement.getElement(data.observedName, data.accessibility);\n      }\n    }\n\n    return element || null;\n  }\n\n  static getElementData(tabster, element, getOwner, context, ownerUId) {\n    const deloser = DeloserAPI.getDeloser(tabster, element);\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const tabsterOnElement = getTabsterOnElement(tabster, element);\n    const observed = tabsterOnElement && tabsterOnElement.observed;\n    return {\n      uid: getElementUId(getOwner, element),\n      ownerUId,\n      id: element.id || undefined,\n      rootUId: ctx ? ctx.root.uid : undefined,\n      deloserUId: deloser ? getDeloserUID(getOwner, context, deloser) : undefined,\n      observedName: observed && observed.names && observed.names[0],\n      observedDetails: observed && observed.details\n    };\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerUId, transactions, forwardResult) {\n    const beginData = data.beginData;\n    let element;\n    let dataOut;\n\n    if (beginData === undefined) {\n      element = tabster.focusedElement.getFocusedElement();\n    } else if (beginData) {\n      element = GetElementTransaction.findElement(tabster, getOwner, beginData) || undefined;\n    }\n\n    if (!element && beginData) {\n      const name = beginData.observedName;\n      const timeout = data.timeout;\n      const accessibility = beginData.accessibility;\n\n      if (name && timeout) {\n        const e = await new (getPromise(getOwner))(resolve => {\n          let isWaitElementResolved = false;\n          let isForwardResolved = false;\n          let isResolved = false; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n          tabster.observedElement.waitElement(name, timeout, accessibility).result.then(value => {\n            isWaitElementResolved = true;\n\n            if (!isResolved && (value || isForwardResolved)) {\n              isResolved = true;\n              resolve({\n                element: value\n              });\n            }\n          });\n          forwardResult.then(value => {\n            isForwardResolved = true;\n\n            if (!isResolved && (value || isWaitElementResolved)) {\n              isResolved = true;\n              resolve({\n                crossOrigin: value\n              });\n            }\n          });\n        });\n\n        if (e.element) {\n          element = e.element;\n        } else if (e.crossOrigin) {\n          dataOut = e.crossOrigin;\n        }\n      }\n    }\n\n    return element ? GetElementTransaction.getElementData(tabster, element, getOwner, transactions.ctx, ownerUId) : dataOut;\n  }\n\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const forwardRet = await forwardResult;\n    const begin = !forwardRet && data.beginData;\n    const uid = begin && begin.deloserUId;\n    const deloser = uid && transactions.ctx.deloserByUId[uid];\n    const deloserAPI = tabster.deloser;\n\n    if (begin && deloser && deloserAPI) {\n      const history = DeloserAPI.getHistory(deloserAPI);\n      return begin.reset ? history.resetFocus(deloser) : history.focusAvailable(deloser);\n    }\n\n    return !!forwardRet;\n  }\n\n}\n\nclass PingTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Ping;\n  }\n\n  static shouldForward() {\n    return false;\n  }\n\n  static async makeResponse() {\n    return true;\n  }\n\n}\n\nclass CrossOriginTransactions {\n  constructor(tabster, getOwner, context) {\n    this._knownTargets = {};\n    this._transactions = {};\n    this._isDefaultSendUp = false;\n    this.isSetUp = false;\n\n    this._onMessage = e => {\n      if (e.data.owner === this._ownerUId || !this._tabster) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const data = e.data;\n      let transactionId;\n\n      if (!data || !(transactionId = data.transaction) || !data.type || !data.timestamp || !data.owner || !data.sentto) {\n        return;\n      }\n\n      let knownTarget = this._knownTargets[data.owner];\n\n      if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n        knownTarget = this._knownTargets[data.owner] = {\n          send: e.send\n        };\n      }\n\n      if (knownTarget) {\n        knownTarget.last = Date.now();\n      }\n\n      if (data.isResponse) {\n        const t = this._transactions[transactionId];\n\n        if (t && t.transaction && t.transaction.type === data.type) {\n          t.transaction.onResponse(data);\n        }\n      } else {\n        const Transaction = this._getTransactionClass(data.type);\n\n        const forwardResult = this.forwardTransaction(data);\n\n        if (Transaction && e.send) {\n          Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, forwardResult, false).then(r => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const response = {\n              transaction: data.transaction,\n              type: data.type,\n              isResponse: true,\n              timestamp: Date.now(),\n              owner: this._ownerUId,\n              timeout: data.timeout,\n              sentto: {},\n              target: data.target === _targetIdUp ? _targetIdUp : data.owner,\n              endData: r\n            };\n            e.send(response);\n          });\n        }\n      }\n    };\n\n    this._onPageHide = () => {\n      this._dead();\n    };\n\n    this._onBrowserMessage = e => {\n      if (e.source === this._owner()) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const send = data => {\n        if (e.source && e.source.postMessage) {\n          // eslint-disable-next-line @typescript-eslint/ban-types\n          e.source.postMessage(JSON.stringify(data), \"*\");\n        }\n      };\n\n      try {\n        this._onMessage({\n          data: JSON.parse(e.data),\n          send\n        });\n      } catch (e) {\n        /* Ignore */\n      }\n    };\n\n    this._tabster = tabster;\n    this._owner = getOwner;\n    this._ownerUId = getWindowUId(getOwner());\n    this.ctx = context;\n  }\n\n  setup(sendUp) {\n    if (this.isSetUp) {\n      if (process.env.NODE_ENV === 'development') {\n        console.error(\"CrossOrigin is already set up.\");\n      }\n    } else {\n      this.isSetUp = true;\n      this.setSendUp(sendUp);\n\n      this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n      this._ping();\n    }\n\n    return this._onMessage;\n  }\n\n  setSendUp(sendUp) {\n    if (!this.isSetUp) {\n      throw new Error(\"CrossOrigin is not set up.\");\n    }\n\n    this.sendUp = sendUp || undefined;\n\n    const owner = this._owner();\n\n    if (sendUp === undefined) {\n      if (!this._isDefaultSendUp) {\n        if (owner.document) {\n          this._isDefaultSendUp = true;\n\n          if (owner.parent && owner.parent !== owner && owner.parent.postMessage) {\n            this.sendUp = ( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data) => {\n              owner.parent.postMessage(JSON.stringify(data), \"*\");\n            };\n          }\n\n          owner.addEventListener(\"message\", this._onBrowserMessage);\n        }\n      }\n    } else if (this._isDefaultSendUp) {\n      owner.removeEventListener(\"message\", this._onBrowserMessage);\n      this._isDefaultSendUp = false;\n    }\n\n    return this._onMessage;\n  }\n\n  async dispose() {\n    const owner = this._owner();\n\n    if (this._pingTimer) {\n      owner.clearTimeout(this._pingTimer);\n      this._pingTimer = undefined;\n    }\n\n    owner.removeEventListener(\"message\", this._onBrowserMessage);\n    owner.removeEventListener(\"pagehide\", this._onPageHide);\n    await this._dead();\n    delete this._deadPromise;\n\n    for (const id of Object.keys(this._transactions)) {\n      const t = this._transactions[id];\n\n      if (t.timer) {\n        owner.clearTimeout(t.timer);\n        delete t.timer;\n      }\n\n      t.transaction.end();\n    }\n\n    this._knownTargets = {};\n    delete this.sendUp;\n  }\n\n  beginTransaction(Transaction, value, timeout, sentTo, targetId, withReject) {\n    if (!this._owner) {\n      return getPromise(this._owner).reject();\n    }\n\n    const transaction = new Transaction(this._tabster, this._owner, this._knownTargets, value, timeout, sentTo, targetId, this.sendUp);\n    let selfResponse;\n\n    if (Transaction.shouldSelfRespond && Transaction.shouldSelfRespond(this._tabster, value, this._owner, this._ownerUId)) {\n      selfResponse = data => {\n        return Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, getPromise(this._owner).resolve(undefined), true);\n      };\n    }\n\n    return this._beginTransaction(transaction, timeout, selfResponse, withReject);\n  }\n\n  removeTarget(uid) {\n    delete this._knownTargets[uid];\n  }\n\n  _beginTransaction(transaction, timeout, selfResponse, withReject) {\n    const owner = this._owner();\n\n    const wrapper = {\n      transaction,\n      timer: owner.setTimeout(() => {\n        delete wrapper.timer;\n        transaction.end(\"Cross origin transaction timed out.\");\n      }, _transactionTimeout + (timeout || 0))\n    };\n    this._transactions[transaction.id] = wrapper;\n    const ret = transaction.begin(selfResponse);\n    ret.catch(() => {\n      /**/\n    }).finally(() => {\n      if (wrapper.timer) {\n        owner.clearTimeout(wrapper.timer);\n      }\n\n      delete this._transactions[transaction.id];\n    });\n    return ret.then(value => value, withReject ? undefined : () => undefined);\n  }\n\n  forwardTransaction( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const owner = this._owner;\n    let targetId = data.target;\n\n    if (targetId === this._ownerUId) {\n      return getPromise(owner).resolve();\n    }\n\n    const Transaction = this._getTransactionClass(data.type);\n\n    if (Transaction) {\n      if (Transaction.shouldForward === undefined || Transaction.shouldForward(this._tabster, data, owner, this._ownerUId)) {\n        const sentTo = data.sentto;\n\n        if (targetId === _targetIdUp) {\n          targetId = undefined;\n          sentTo[this._ownerUId] = true;\n        }\n\n        delete sentTo[_targetIdUp];\n        return this._beginTransaction(new Transaction(this._tabster, owner, this._knownTargets, data.beginData, data.timeout, sentTo, targetId, this.sendUp), data.timeout);\n      } else {\n        return getPromise(owner).resolve();\n      }\n    }\n\n    return getPromise(owner).reject(`Unknown transaction type ${data.type}`);\n  }\n\n  _getTransactionClass(type // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    switch (type) {\n      case CrossOriginTransactionTypes.Bootstrap:\n        return BootstrapTransaction;\n\n      case CrossOriginTransactionTypes.FocusElement:\n        return FocusElementTransaction;\n\n      case CrossOriginTransactionTypes.State:\n        return StateTransaction;\n\n      case CrossOriginTransactionTypes.GetElement:\n        return GetElementTransaction;\n\n      case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n        return RestoreFocusInDeloserTransaction;\n\n      case CrossOriginTransactionTypes.Ping:\n        return PingTransaction;\n\n      default:\n        return null;\n    }\n  }\n\n  async _dead() {\n    if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n      this._deadPromise = this.beginTransaction(StateTransaction, {\n        ownerUId: this._ownerUId,\n        state: CrossOriginStates.DeadWindow\n      });\n    }\n\n    if (this._deadPromise) {\n      await this._deadPromise;\n    }\n  }\n\n  async _ping() {\n    if (this._pingTimer) {\n      return;\n    }\n\n    let deadWindows;\n    const now = Date.now();\n    const targets = Object.keys(this._knownTargets).filter(uid => now - (this._knownTargets[uid].last || 0) > _pingTimeout);\n\n    if (this.sendUp) {\n      targets.push(_targetIdUp);\n    }\n\n    if (targets.length) {\n      await getPromise(this._owner).all(targets.map(uid => this.beginTransaction(PingTransaction, undefined, undefined, undefined, uid, true).then(() => true, () => {\n        if (uid !== _targetIdUp) {\n          if (!deadWindows) {\n            deadWindows = {};\n          }\n\n          deadWindows[uid] = true;\n          delete this._knownTargets[uid];\n        }\n\n        return false;\n      })));\n    }\n\n    if (deadWindows) {\n      const focused = await this.beginTransaction(GetElementTransaction, undefined);\n\n      if (!focused && this.ctx.focusOwner && this.ctx.focusOwner in deadWindows) {\n        await this.beginTransaction(StateTransaction, {\n          ownerUId: this._ownerUId,\n          state: CrossOriginStates.Blurred,\n          force: true\n        });\n        const deloserAPI = this._tabster.deloser;\n\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n    }\n\n    this._pingTimer = this._owner().setTimeout(() => {\n      this._pingTimer = undefined;\n\n      this._ping();\n    }, _pingTimeout);\n  }\n\n}\n\nclass CrossOriginElement {\n  constructor(tabster, uid, ownerId, id, rootId, observedName, observedDetails) {\n    this._tabster = tabster;\n    this.uid = uid;\n    this.ownerId = ownerId;\n    this.id = id;\n    this.rootId = rootId;\n    this.observedName = observedName;\n    this.observedDetails = observedDetails;\n  }\n\n  focus(noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tabster.crossOrigin.focusedElement.focus(this, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n}\nclass CrossOriginFocusedElementState extends Subscribable {\n  constructor(transactions) {\n    super();\n    this._transactions = transactions;\n  }\n\n  async focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      uid: element.uid,\n      id: element.id,\n      rootId: element.rootId,\n      ownerId: element.ownerId,\n      observedName: element.observedName\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n  async focusById(elementId, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      id: elementId,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n  async focusByObservedName(observedName, timeout, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      observedName,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout);\n  }\n\n  async _focus(elementData, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout) {\n    return this._transactions.beginTransaction(FocusElementTransaction, { ...elementData,\n      noFocusedProgrammaticallyFlag,\n      noAccessibleCheck\n    }, timeout).then(value => !!value);\n  }\n\n  static setVal(instance, val, detail) {\n    instance.setVal(val, detail);\n  }\n\n}\nclass CrossOriginObservedElementState extends Subscribable {\n  constructor(tabster, transactions) {\n    super();\n    this._lastRequestFocusId = 0;\n    this._tabster = tabster;\n    this._transactions = transactions;\n  }\n\n  async getElement(observedName, accessibility) {\n    return this.waitElement(observedName, 0, accessibility);\n  }\n\n  async waitElement(observedName, timeout, accessibility) {\n    return this._transactions.beginTransaction(GetElementTransaction, {\n      observedName,\n      accessibility\n    }, timeout).then(value => value ? StateTransaction.createElement(this._tabster, value) : null);\n  }\n\n  async requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    return this.waitElement(observedName, timeout, ObservedElementAccessibilities.Focusable).then(element => this._lastRequestFocusId === requestId && element ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._tabster.crossOrigin.focusedElement.focus(element, true) : false);\n  }\n\n  static trigger(instance, element, details) {\n    instance.trigger(element, details);\n  }\n\n}\nclass CrossOriginAPI {\n  constructor(tabster) {\n    this._init = () => {\n      const tabster = this._tabster;\n      tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      tabster.focusedElement.subscribe(this._onFocus); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      tabster.observedElement.subscribe(this._onObserved);\n\n      if (!this._ctx.origOutlineSetup) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this._ctx.origOutlineSetup = tabster.outline.setup; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        tabster.outline.setup = this._outlineSetup;\n      }\n\n      this._transactions.beginTransaction(BootstrapTransaction, undefined, undefined, undefined, _targetIdUp).then(data => {\n        if (data && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !== data.isNavigatingWithKeyboard) {\n          this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n\n          this._tabster.keyboardNavigation.setNavigatingWithKeyboard(data.isNavigatingWithKeyboard);\n\n          this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n        }\n      });\n    };\n\n    this._onKeyboardNavigationStateChanged = value => {\n      if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n        this._transactions.beginTransaction(StateTransaction, {\n          state: CrossOriginStates.KeyboardNavigation,\n          ownerUId: getWindowUId(this._win()),\n          isNavigatingWithKeyboard: value\n        });\n      }\n    };\n\n    this._onFocus = element => {\n      const win = this._win();\n\n      const ownerUId = getWindowUId(win);\n\n      if (this._blurTimer) {\n        win.clearTimeout(this._blurTimer);\n        this._blurTimer = undefined;\n      }\n\n      if (element) {\n        this._transactions.beginTransaction(StateTransaction, { ...GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, ownerUId),\n          state: CrossOriginStates.Focused\n        });\n      } else {\n        this._blurTimer = win.setTimeout(() => {\n          this._blurTimer = undefined;\n\n          if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n            this._transactions.beginTransaction(GetElementTransaction, undefined).then(value => {\n              if (!value && this._ctx.focusOwner === ownerUId) {\n                this._transactions.beginTransaction(StateTransaction, {\n                  ownerUId,\n                  state: CrossOriginStates.Blurred,\n                  force: false\n                });\n              }\n            });\n          }\n        }, 0);\n      }\n    };\n\n    this._onObserved = (element, details) => {\n      var _a;\n\n      const d = GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, getWindowUId(this._win()));\n      d.state = CrossOriginStates.Observed;\n      d.observedName = (_a = details.names) === null || _a === void 0 ? void 0 : _a[0];\n      d.observedDetails = details.details;\n\n      this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    this._outlineSetup = props => {\n      this._transactions.beginTransaction(StateTransaction, {\n        state: CrossOriginStates.Outline,\n        ownerUId: getWindowUId(this._win()),\n        outline: props\n      });\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._ctx = {\n      ignoreKeyboardNavigationStateUpdate: false,\n      deloserByUId: {}\n    };\n    this._transactions = new CrossOriginTransactions(tabster, this._win, this._ctx);\n    this.focusedElement = new CrossOriginFocusedElementState(this._transactions);\n    this.observedElement = new CrossOriginObservedElementState(tabster, this._transactions);\n  }\n\n  setup(sendUp) {\n    if (this.isSetUp()) {\n      return this._transactions.setSendUp(sendUp);\n    } else {\n      this._tabster.queueInit(this._init);\n\n      return this._transactions.setup(sendUp);\n    }\n  }\n\n  isSetUp() {\n    return this._transactions.isSetUp;\n  }\n\n  dispose() {\n    var _a;\n\n    const tabster = this._tabster;\n    tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = tabster.observedElement) === null || _a === void 0 ? void 0 : _a.unsubscribe(this._onObserved);\n\n    this._transactions.dispose();\n\n    this.focusedElement.dispose();\n    this.observedElement.dispose();\n    this._ctx.deloserByUId = {};\n  }\n\n}\n\nfunction getDeloserUID(getWindow, context, deloser) {\n  const deloserElement = deloser.getElement();\n\n  if (deloserElement) {\n    const uid = getElementUId(getWindow, deloserElement);\n\n    if (!context.deloserByUId[uid]) {\n      context.deloserByUId[uid] = deloser;\n    }\n\n    return uid;\n  }\n\n  return undefined;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass FocusableAPI {\n  constructor(tabster) {\n    this._tabster = tabster;\n  }\n\n  dispose() {\n    /**/\n  }\n\n  getProps(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    return tabsterOnElement && tabsterOnElement.focusable || {};\n  }\n\n  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {\n    if (matchesSelector(el, FOCUSABLE_SELECTOR) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {\n      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));\n    }\n\n    return false;\n  }\n\n  isVisible(el) {\n    if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n      return false;\n    }\n\n    if (isDisplayNone(el)) {\n      return false;\n    }\n\n    const rect = el.ownerDocument.body.getBoundingClientRect();\n\n    if (rect.width === 0 && rect.height === 0) {\n      // This might happen, for example, if our <body> is in hidden <iframe>.\n      return false;\n    }\n\n    return true;\n  }\n\n  isAccessible(el) {\n    var _a;\n\n    for (let e = el; e; e = dom.getParentElement(e)) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n      if (this._isHidden(e)) {\n        return false;\n      }\n\n      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;\n\n      if (!ignoreDisabled && this._isDisabled(e)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _isDisabled(el) {\n    return el.hasAttribute(\"disabled\");\n  }\n\n  _isHidden(el) {\n    var _a;\n\n    const attrVal = el.getAttribute(\"aria-hidden\");\n\n    if (attrVal && attrVal.toLowerCase() === \"true\") {\n      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  findFirst(options, out) {\n    return this.findElement({ ...options\n    }, out);\n  }\n\n  findLast(options, out) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    }, out);\n  }\n\n  findNext(options, out) {\n    return this.findElement({ ...options\n    }, out);\n  }\n\n  findPrev(options, out) {\n    return this.findElement({ ...options,\n      isBackward: true\n    }, out);\n  }\n\n  findDefault(options, out) {\n    return this.findElement({ ...options,\n      acceptCondition: el => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault\n    }, out) || null;\n  }\n\n  findAll(options) {\n    return this._findElements(true, options) || [];\n  }\n\n  findElement(options, out) {\n    const found = this._findElements(false, options, out);\n\n    return found ? found[0] : found;\n  }\n\n  _findElements(isFindAll, options, out) {\n    var _a, _b, _c;\n\n    const {\n      container,\n      currentElement = null,\n      includeProgrammaticallyFocusable,\n      useActiveModalizer,\n      ignoreAccessibility,\n      modalizerId,\n      isBackward,\n      onElement\n    } = options;\n\n    if (!out) {\n      out = {};\n    }\n\n    const elements = [];\n    let {\n      acceptCondition\n    } = options;\n    const hasCustomCondition = !!acceptCondition;\n\n    if (!container) {\n      return null;\n    }\n\n    if (!acceptCondition) {\n      acceptCondition = el => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);\n    }\n\n    const acceptElementState = {\n      container,\n      modalizerUserId: modalizerId === undefined && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),\n      from: currentElement || container,\n      isBackward,\n      isFindAll,\n      acceptCondition,\n      hasCustomCondition,\n      includeProgrammaticallyFocusable,\n      ignoreAccessibility,\n      cachedGrouppers: {},\n      cachedRadioGroups: {}\n    };\n    const walker = createElementTreeWalker(container.ownerDocument, container, node => this._acceptElement(node, acceptElementState));\n\n    if (!walker) {\n      return null;\n    }\n\n    const prepareForNextElement = shouldContinueIfNotFound => {\n      var _a, _b;\n\n      const foundElement = (_a = acceptElementState.foundElement) !== null && _a !== void 0 ? _a : acceptElementState.foundBackward;\n\n      if (foundElement) {\n        elements.push(foundElement);\n      }\n\n      if (isFindAll) {\n        if (foundElement) {\n          acceptElementState.found = false;\n          delete acceptElementState.foundElement;\n          delete acceptElementState.foundBackward;\n          delete acceptElementState.fromCtx;\n          acceptElementState.from = foundElement;\n\n          if (onElement && !onElement(foundElement)) {\n            return false;\n          }\n        }\n\n        return !!(foundElement || shouldContinueIfNotFound);\n      } else {\n        if (foundElement && out) {\n          out.uncontrolled = (_b = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b === void 0 ? void 0 : _b.uncontrolled;\n        }\n\n        return !!(shouldContinueIfNotFound && !foundElement);\n      }\n    };\n\n    if (!currentElement) {\n      out.outOfDOMOrder = true;\n    }\n\n    if (currentElement && dom.nodeContains(container, currentElement)) {\n      walker.currentNode = currentElement;\n    } else if (isBackward) {\n      const lastChild = getLastChild$2(container);\n\n      if (!lastChild) {\n        return null;\n      }\n\n      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {\n        if (acceptElementState.skippedFocusable) {\n          out.outOfDOMOrder = true;\n        }\n\n        return elements;\n      }\n\n      walker.currentNode = lastChild;\n    }\n\n    do {\n      if (isBackward) {\n        walker.previousNode();\n      } else {\n        walker.nextNode();\n      }\n    } while (prepareForNextElement());\n\n    if (acceptElementState.skippedFocusable) {\n      out.outOfDOMOrder = true;\n    }\n\n    return elements.length ? elements : null;\n  }\n\n  _acceptElement(element, state) {\n    var _a, _b, _c;\n\n    if (state.found) {\n      return NodeFilter.FILTER_ACCEPT;\n    }\n\n    const foundBackward = state.foundBackward;\n\n    if (foundBackward && (element === foundBackward || !dom.nodeContains(foundBackward, element))) {\n      state.found = true;\n      state.foundElement = foundBackward;\n      return NodeFilter.FILTER_ACCEPT;\n    }\n\n    const container = state.container;\n\n    if (element === container) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    if (!dom.nodeContains(container, element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    if (getDummyInputContainer(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    if (dom.nodeContains(state.rejectElementsFrom, element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element); // Tabster is opt in, if it is not managed, don't try and get do anything special\n\n    if (!ctx) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    if (shouldIgnoreFocus(element)) {\n      if (this.isFocusable(element, undefined, true, true)) {\n        state.skippedFocusable = true;\n      }\n\n      return NodeFilter.FILTER_SKIP;\n    } // We assume iframes are focusable because native tab behaviour would tab inside.\n    // But we do it only during the standard search when there is no custom accept\n    // element condition.\n\n\n    if (!state.hasCustomCondition && (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\")) {\n      if (((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        state.found = true;\n        state.rejectElementsFrom = state.foundElement = element;\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n\n    if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n      if (this.isFocusable(element, false, true, true)) {\n        state.skippedFocusable = true;\n      }\n\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    let result;\n    let fromCtx = state.fromCtx;\n\n    if (!fromCtx) {\n      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);\n    }\n\n    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;\n    let groupper = ctx.groupper;\n    let mover = ctx.mover;\n    result = (_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.acceptElement(element, state);\n\n    if (result !== undefined) {\n      state.skippedFocusable = true;\n    }\n\n    if (result === undefined && (groupper || mover || fromMover)) {\n      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();\n      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();\n\n      if (moverElement && dom.nodeContains(fromMoverElement, moverElement) && dom.nodeContains(container, fromMoverElement) && (!groupperElement || !mover || dom.nodeContains(fromMoverElement, groupperElement))) {\n        mover = fromMover;\n        moverElement = fromMoverElement;\n      }\n\n      if (groupperElement && (groupperElement === container || !dom.nodeContains(container, groupperElement))) {\n        groupper = undefined;\n      }\n\n      if (moverElement && !dom.nodeContains(container, moverElement)) {\n        mover = undefined;\n      }\n\n      if (groupper && mover) {\n        if (moverElement && groupperElement && !dom.nodeContains(groupperElement, moverElement)) {\n          mover = undefined;\n        } else {\n          groupper = undefined;\n        }\n      }\n\n      if (groupper) {\n        result = groupper.acceptElement(element, state);\n      }\n\n      if (mover) {\n        result = mover.acceptElement(element, state);\n      }\n    }\n\n    if (result === undefined) {\n      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n\n      if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element, false, true, true)) {\n        state.skippedFocusable = true;\n      }\n    }\n\n    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n      if (!state.isFindAll && isRadio(element) && !element.checked) {\n        // We need to mimic the browser's behaviour to skip unchecked radio buttons.\n        const radioGroupName = element.name;\n        let radioGroup = state.cachedRadioGroups[radioGroupName];\n\n        if (!radioGroup) {\n          radioGroup = getRadioButtonGroup(element);\n\n          if (radioGroup) {\n            state.cachedRadioGroups[radioGroupName] = radioGroup;\n          }\n        }\n\n        if ((radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.checked) && radioGroup.checked !== element) {\n          // Currently found element is a radio button in a group that has another radio button checked.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n\n      if (state.isBackward) {\n        // When TreeWalker goes backwards, it visits the container first,\n        // then it goes inside. So, if the container is accepted, we remember it,\n        // but allowing the TreeWalker to check inside.\n        state.foundBackward = element;\n        result = NodeFilter.FILTER_SKIP;\n      } else {\n        state.found = true;\n        state.foundElement = element;\n      }\n    }\n\n    return result;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst Keys = {\n  Tab: \"Tab\",\n  Enter: \"Enter\",\n  Escape: \"Escape\",\n  Space: \" \",\n  PageUp: \"PageUp\",\n  PageDown: \"PageDown\",\n  End: \"End\",\n  Home: \"Home\",\n  ArrowLeft: \"ArrowLeft\",\n  ArrowUp: \"ArrowUp\",\n  ArrowRight: \"ArrowRight\",\n  ArrowDown: \"ArrowDown\"\n};\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nfunction getUncontrolledCompletelyContainer(tabster, element) {\n  var _a;\n\n  const getParent = tabster.getParent;\n  let el = element;\n\n  do {\n    const uncontrolledOnElement = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.uncontrolled;\n\n    if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) {\n      return el;\n    }\n\n    el = getParent(el);\n  } while (el);\n\n  return undefined;\n}\n\nconst AsyncFocusIntentPriorityBySource = {\n  [AsyncFocusSources.Restorer]: 0,\n  [AsyncFocusSources.Deloser]: 1,\n  [AsyncFocusSources.EscapeGroupper]: 2\n};\nclass FocusedElementState extends Subscribable {\n  constructor(tabster, getWindow) {\n    super();\n\n    this._init = () => {\n      const win = this._win();\n\n      const doc = win.document; // Add these event listeners as capture - we want Tabster to run before user event handlers\n\n      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n      doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      const activeElement = dom.getActiveElement(doc);\n\n      if (activeElement && activeElement !== doc.body) {\n        this._setFocusedElement(activeElement);\n      }\n\n      this.subscribe(this._onChanged);\n    };\n\n    this._onFocusIn = e => {\n      const target = e.composedPath()[0];\n\n      if (target) {\n        this._setFocusedElement(target, e.detail.relatedTarget, e.detail.isFocusedProgrammatically);\n      }\n    };\n\n    this._onFocusOut = e => {\n      var _a;\n\n      this._setFocusedElement(undefined, (_a = e.detail) === null || _a === void 0 ? void 0 : _a.originalEvent.relatedTarget);\n    }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._validateFocusedElement = element => {// TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    this._onKeyDown = event => {\n      if (event.key !== Keys.Tab || event.ctrlKey) {\n        return;\n      }\n\n      const currentElement = this.getVal();\n\n      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === \"true\") {\n        return;\n      }\n\n      const tabster = this._tabster;\n      const controlTab = tabster.controlTab;\n      const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n      if (!ctx || ctx.ignoreKeydown(event)) {\n        return;\n      }\n\n      const isBackward = event.shiftKey;\n      const next = FocusedElementState.findNextTabbable(tabster, ctx, undefined, currentElement, undefined, isBackward, true);\n      const rootElement = ctx.root.getElement();\n\n      if (!rootElement) {\n        return;\n      }\n\n      const nextElement = next === null || next === void 0 ? void 0 : next.element;\n      const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster, currentElement);\n\n      if (nextElement) {\n        const nextUncontrolled = next.uncontrolled;\n\n        if (ctx.uncontrolled || dom.nodeContains(nextUncontrolled, currentElement)) {\n          if (!next.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !dom.nodeContains(uncontrolledCompletelyContainer, nextElement)) {\n            // Nothing to do, everything will be done by the browser or something\n            // that controls the uncontrolled area.\n            return;\n          } // We are in uncontrolled area. We allow whatever controls it to move\n          // focus, but we add a phantom dummy to make sure the focus is moved\n          // to the correct place if the uncontrolled area allows default action.\n          // We only need that in the controlled mode, because in uncontrolled\n          // mode we have dummy inputs around everything that redirects focus.\n\n\n          DummyInputManager.addPhantomDummyWithTarget(tabster, currentElement, isBackward, nextElement);\n          return;\n        }\n\n        if (nextUncontrolled || nextElement.tagName === \"IFRAME\") {\n          // For iframes and uncontrolled areas we always want to use default action to\n          // move focus into.\n          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"root\",\n            owner: rootElement,\n            next: nextElement,\n            relatedEvent: event\n          }))) {\n            DummyInputManager.moveWithPhantomDummy(this._tabster, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward, event);\n          }\n\n          return;\n        }\n\n        if (controlTab || (next === null || next === void 0 ? void 0 : next.outOfDOMOrder)) {\n          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({\n            by: \"root\",\n            owner: rootElement,\n            next: nextElement,\n            relatedEvent: event\n          }))) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            nativeFocus(nextElement);\n          }\n        }\n      } else {\n        if (!uncontrolledCompletelyContainer && rootElement.dispatchEvent(new TabsterMoveFocusEvent({\n          by: \"root\",\n          owner: rootElement,\n          next: null,\n          relatedEvent: event\n        }))) {\n          ctx.root.moveOutWithDefaultAction(isBackward, event);\n        }\n      }\n    };\n\n    this._onChanged = (element, detail) => {\n      var _a, _b;\n\n      if (element) {\n        element.dispatchEvent(new TabsterFocusInEvent(detail));\n      } else {\n        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (last) {\n          const d = { ...detail\n          };\n          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n\n          if (modalizerId) {\n            d.modalizerId = modalizerId;\n          }\n\n          last.dispatchEvent(new TabsterFocusOutEvent(d));\n        }\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    super.dispose();\n\n    const win = this._win();\n\n    const doc = win.document;\n    doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n    doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    this.unsubscribe(this._onChanged);\n    const asyncFocus = this._asyncFocus;\n\n    if (asyncFocus) {\n      win.clearTimeout(asyncFocus.timeout);\n      delete this._asyncFocus;\n    }\n\n    delete FocusedElementState._lastResetElement;\n    delete this._nextVal;\n    delete this._lastVal;\n  }\n\n  static forgetMemorized(instance, parent) {\n    var _a, _b;\n\n    let wel = FocusedElementState._lastResetElement;\n    let el = wel && wel.get();\n\n    if (el && dom.nodeContains(parent, el)) {\n      delete FocusedElementState._lastResetElement;\n    }\n\n    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();\n\n    if (el && dom.nodeContains(parent, el)) {\n      delete instance._nextVal;\n    }\n\n    wel = instance._lastVal;\n    el = wel && wel.get();\n\n    if (el && dom.nodeContains(parent, el)) {\n      delete instance._lastVal;\n    }\n  }\n\n  getFocusedElement() {\n    return this.getVal();\n  }\n\n  getLastFocusedElement() {\n    var _a;\n\n    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n\n    if (!el || el && !documentContains(el.ownerDocument, el)) {\n      this._lastVal = el = undefined;\n    }\n\n    return el;\n  }\n\n  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck, preventScroll) {\n    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {\n      return false;\n    }\n\n    element.focus({\n      preventScroll\n    });\n    return true;\n  }\n\n  focusDefault(container) {\n    const el = this._tabster.focusable.findDefault({\n      container\n    });\n\n    if (el) {\n      this._tabster.focusedElement.focus(el);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  getFirstOrLastTabbable(isFirst, props) {\n    var _a;\n\n    const {\n      container,\n      ignoreAccessibility\n    } = props;\n    let toFocus;\n\n    if (container) {\n      const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n      if (ctx) {\n        toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, container, undefined, undefined, !isFirst, ignoreAccessibility)) === null || _a === void 0 ? void 0 : _a.element;\n      }\n    }\n\n    if (toFocus && !dom.nodeContains(container, toFocus)) {\n      toFocus = undefined;\n    }\n\n    return toFocus || undefined;\n  }\n\n  _focusFirstOrLast(isFirst, props) {\n    const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n    if (toFocus) {\n      this.focus(toFocus, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  focusFirst(props) {\n    return this._focusFirstOrLast(true, props);\n  }\n\n  focusLast(props) {\n    return this._focusFirstOrLast(false, props);\n  }\n\n  resetFocus(container) {\n    if (!this._tabster.focusable.isVisible(container)) {\n      return false;\n    }\n\n    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n      const prevTabIndex = container.getAttribute(\"tabindex\");\n      const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n      container.tabIndex = -1;\n      container.setAttribute(\"aria-hidden\", \"true\");\n      FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);\n      this.focus(container, true, true);\n\n      this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n\n      this._setOrRemoveAttribute(container, \"aria-hidden\", prevAriaHidden);\n    } else {\n      this.focus(container);\n    }\n\n    return true;\n  }\n\n  requestAsyncFocus(source, callback, delay) {\n    const win = this._tabster.getWindow();\n\n    const currentAsyncFocus = this._asyncFocus;\n\n    if (currentAsyncFocus) {\n      if (AsyncFocusIntentPriorityBySource[source] > AsyncFocusIntentPriorityBySource[currentAsyncFocus.source]) {\n        // Previously registered intent has higher priority.\n        return;\n      } // New intent has higher priority.\n\n\n      win.clearTimeout(currentAsyncFocus.timeout);\n    }\n\n    this._asyncFocus = {\n      source,\n      callback,\n      timeout: win.setTimeout(() => {\n        this._asyncFocus = undefined;\n        callback();\n      }, delay)\n    };\n  }\n\n  cancelAsyncFocus(source) {\n    const asyncFocus = this._asyncFocus;\n\n    if ((asyncFocus === null || asyncFocus === void 0 ? void 0 : asyncFocus.source) === source) {\n      this._tabster.getWindow().clearTimeout(asyncFocus.timeout);\n\n      this._asyncFocus = undefined;\n    }\n  }\n\n  _setOrRemoveAttribute(element, name, value) {\n    if (value === null) {\n      element.removeAttribute(name);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n\n  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {\n    var _a, _b;\n\n    if (this._tabster._noop) {\n      return;\n    }\n\n    const detail = {\n      relatedTarget\n    };\n\n    if (element) {\n      const lastResetElement = (_a = FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();\n      FocusedElementState._lastResetElement = undefined;\n\n      if (lastResetElement === element || shouldIgnoreFocus(element)) {\n        return;\n      }\n\n      detail.isFocusedProgrammatically = isFocusedProgrammatically;\n      const ctx = RootAPI.getTabsterContext(this._tabster, element);\n      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n\n      if (modalizerId) {\n        detail.modalizerId = modalizerId;\n      }\n    }\n\n    const nextVal = this._nextVal = {\n      element: element ? new WeakHTMLElement(this._win, element) : undefined,\n      detail\n    };\n\n    if (element && element !== this._val) {\n      this._validateFocusedElement(element);\n    } // _validateFocusedElement() might cause the refocus which will trigger\n    // another call to this function. Making sure that the value is correct.\n\n\n    if (this._nextVal === nextVal) {\n      this.setVal(element, detail);\n    }\n\n    this._nextVal = undefined;\n  }\n\n  setVal(val, detail) {\n    super.setVal(val, detail);\n\n    if (val) {\n      this._lastVal = new WeakHTMLElement(this._win, val);\n    }\n  }\n\n  static findNextTabbable(tabster, ctx, container, currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    const actualContainer = container || ctx.root.getElement();\n\n    if (!actualContainer) {\n      return null;\n    }\n\n    let next = null;\n    const isTabbingTimer = FocusedElementState._isTabbingTimer;\n    const win = tabster.getWindow();\n\n    if (isTabbingTimer) {\n      win.clearTimeout(isTabbingTimer);\n    }\n\n    FocusedElementState.isTabbing = true;\n    FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n      delete FocusedElementState._isTabbingTimer;\n      FocusedElementState.isTabbing = false;\n    }, 0);\n    const modalizer = ctx.modalizer;\n    const groupper = ctx.groupper;\n    const mover = ctx.mover;\n\n    const callFindNext = what => {\n      next = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);\n\n      if (currentElement && !(next === null || next === void 0 ? void 0 : next.element)) {\n        const parentElement = what !== modalizer && dom.getParentElement(what.getElement());\n\n        if (parentElement) {\n          const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {\n            referenceElement: parentElement\n          });\n\n          if (parentCtx) {\n            const currentScopeElement = what.getElement();\n            const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild$2(currentScopeElement) || currentScopeElement;\n\n            if (newCurrent) {\n              next = FocusedElementState.findNextTabbable(tabster, parentCtx, container, newCurrent, parentElement, isBackward, ignoreAccessibility);\n\n              if (next) {\n                next.outOfDOMOrder = true;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    if (groupper && mover) {\n      callFindNext(ctx.groupperBeforeMover ? groupper : mover);\n    } else if (groupper) {\n      callFindNext(groupper);\n    } else if (mover) {\n      callFindNext(mover);\n    } else if (modalizer) {\n      callFindNext(modalizer);\n    } else {\n      const findProps = {\n        container: actualContainer,\n        currentElement,\n        referenceElement,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      const nextElement = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      next = {\n        element: nextElement,\n        outOfDOMOrder: findPropsOut.outOfDOMOrder,\n        uncontrolled: findPropsOut.uncontrolled\n      };\n    }\n\n    return next;\n  }\n\n}\nFocusedElementState.isTabbing = false;\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass GroupperDummyManager extends DummyInputManager {\n  constructor(element, groupper, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);\n\n    this._setHandlers((dummyInput, isBackward, relatedTarget) => {\n      var _a, _b;\n\n      const container = element.get();\n      const input = dummyInput.input;\n\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(tabster, input);\n\n        if (ctx) {\n          let next;\n          next = (_a = groupper.findNextTabbable(relatedTarget || undefined, undefined, isBackward, true)) === null || _a === void 0 ? void 0 : _a.element;\n\n          if (!next) {\n            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, undefined, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), undefined, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;\n          }\n\n          if (next) {\n            nativeFocus(next);\n          }\n        }\n      }\n    });\n  }\n\n}\n\nclass Groupper extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._shouldTabInside = false;\n    this.makeTabbable(false);\n    this._onDispose = onDispose;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    const element = this._element.get();\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    delete this.dummyManager;\n\n    if (element) {\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$1(this._element, true);\n      }\n    }\n\n    delete this._first;\n  }\n\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    const groupperElement = this.getElement();\n\n    if (!groupperElement) {\n      return null;\n    }\n\n    const currentIsDummy = getDummyInputContainer(currentElement) === groupperElement;\n\n    if (!this._shouldTabInside && currentElement && dom.nodeContains(groupperElement, currentElement) && !currentIsDummy) {\n      return {\n        element: undefined,\n        outOfDOMOrder: true\n      };\n    }\n\n    const groupperFirstFocusable = this.getFirst(true);\n\n    if (!currentElement || !dom.nodeContains(groupperElement, currentElement) || currentIsDummy) {\n      return {\n        element: groupperFirstFocusable,\n        outOfDOMOrder: true\n      };\n    }\n\n    const tabster = this._tabster;\n    let next = null;\n    let outOfDOMOrder = false;\n    let uncontrolled;\n\n    if (this._shouldTabInside && groupperFirstFocusable) {\n      const findProps = {\n        container: groupperElement,\n        currentElement,\n        referenceElement,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n\n      if (!next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container: groupperElement,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }, findPropsOut);\n        outOfDOMOrder = true;\n      }\n\n      uncontrolled = findPropsOut.uncontrolled;\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n\n  makeTabbable(isTabbable) {\n    this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$1(this._element, !this._shouldTabInside);\n    }\n  }\n\n  isActive(noIfFirstIsFocused) {\n    var _a;\n\n    const element = this.getElement() || null;\n    let isParentActive = true;\n\n    for (let e = dom.getParentElement(element); e; e = dom.getParentElement(e)) {\n      const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;\n\n      if (g) {\n        if (!g._shouldTabInside) {\n          isParentActive = false;\n        }\n      }\n    }\n\n    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : undefined;\n\n    if (ret && noIfFirstIsFocused) {\n      const focused = this._tabster.focusedElement.getFocusedElement();\n\n      if (focused) {\n        ret = focused !== this.getFirst(true);\n      }\n    }\n\n    return ret;\n  }\n\n  getFirst(orContainer) {\n    var _a;\n\n    const groupperElement = this.getElement();\n    let first;\n\n    if (groupperElement) {\n      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {\n        return groupperElement;\n      }\n\n      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();\n\n      if (!first) {\n        first = this._tabster.focusable.findFirst({\n          container: groupperElement,\n          useActiveModalizer: true\n        }) || undefined;\n\n        if (first) {\n          this.setFirst(first);\n        }\n      }\n    }\n\n    return first;\n  }\n\n  setFirst(element) {\n    if (element) {\n      this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n    } else {\n      delete this._first;\n    }\n  }\n\n  acceptElement(element, state) {\n    const cachedGrouppers = state.cachedGrouppers;\n    const parentElement = dom.getParentElement(this.getElement());\n    const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);\n    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupperBeforeMover) ? parentCtxGroupper : undefined;\n    let parentGroupperElement;\n\n    const getIsActive = groupper => {\n      let cached = cachedGrouppers[groupper.id];\n      let isActive;\n\n      if (cached) {\n        isActive = cached.isActive;\n      } else {\n        isActive = this.isActive(true);\n        cached = cachedGrouppers[groupper.id] = {\n          isActive\n        };\n      }\n\n      return isActive;\n    };\n\n    if (parentGroupper) {\n      parentGroupperElement = parentGroupper.getElement();\n\n      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && dom.nodeContains(state.container, parentGroupperElement)) {\n        // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n        state.skippedFocusable = true;\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n\n    const isActive = getIsActive(this);\n    const groupperElement = this.getElement();\n\n    if (groupperElement) {\n      if (isActive !== true) {\n        if (groupperElement === element && parentCtxGroupper) {\n          if (!parentGroupperElement) {\n            parentGroupperElement = parentCtxGroupper.getElement();\n          }\n\n          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && dom.nodeContains(state.container, parentGroupperElement) && parentGroupperElement !== state.container) {\n            state.skippedFocusable = true;\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n\n        if (groupperElement !== element && dom.nodeContains(groupperElement, element)) {\n          state.skippedFocusable = true;\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        const cached = cachedGrouppers[this.id];\n        let first;\n\n        if (\"first\" in cached) {\n          first = cached.first;\n        } else {\n          first = cached.first = this.getFirst(true);\n        }\n\n        if (first && state.acceptCondition(first)) {\n          state.rejectElementsFrom = groupperElement;\n          state.skippedFocusable = true;\n\n          if (first !== state.from) {\n            state.found = true;\n            state.foundElement = first;\n            return NodeFilter.FILTER_ACCEPT;\n          } else {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass GroupperAPI {\n  constructor(tabster, getWindow) {\n    this._current = {};\n    this._grouppers = {};\n\n    this._init = () => {\n      const win = this._win(); // Making sure groupper's onFocus is called before modalizer's onFocus.\n\n\n      this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n      const doc = win.document;\n      const activeElement = dom.getActiveElement(doc);\n\n      if (activeElement) {\n        this._onFocus(activeElement);\n      }\n\n      doc.addEventListener(\"mousedown\", this._onMouseDown, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      win.addEventListener(GroupperMoveFocusEventName, this._onMoveFocus);\n    };\n\n    this._onGroupperDispose = groupper => {\n      delete this._grouppers[groupper.id];\n    };\n\n    this._onFocus = element => {\n      if (element) {\n        this._updateCurrent(element);\n      }\n    };\n\n    this._onMouseDown = e => {\n      let target = e.target;\n\n      while (target && !this._tabster.focusable.isFocusable(target)) {\n        target = this._tabster.getParent(target);\n      }\n\n      if (target) {\n        this._updateCurrent(target);\n      }\n    };\n\n    this._onKeyDown = event => {\n      if (event.key !== Keys.Enter && event.key !== Keys.Escape) {\n        return;\n      } // Give a chance to other listeners to handle the event.\n\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      const element = this._tabster.focusedElement.getFocusedElement();\n\n      if (element) {\n        this.handleKeyPress(element, event);\n      }\n    };\n\n    this._onMoveFocus = e => {\n      var _a;\n\n      const element = e.composedPath()[0];\n      const action = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.action;\n\n      if (element && action !== undefined && !e.defaultPrevented) {\n        if (action === GroupperMoveFocusActions.Enter) {\n          this._enterGroupper(element);\n        } else {\n          this._escapeGroupper(element);\n        }\n\n        e.stopImmediatePropagation();\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    const win = this._win();\n\n    this._tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);\n\n    this._current = {};\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    win.removeEventListener(GroupperMoveFocusEventName, this._onMoveFocus);\n    Object.keys(this._grouppers).forEach(groupperId => {\n      if (this._grouppers[groupperId]) {\n        this._grouppers[groupperId].dispose();\n\n        delete this._grouppers[groupperId];\n      }\n    });\n  }\n\n  createGroupper(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const tabster = this._tabster;\n    const newGroupper = new Groupper(tabster, element, this._onGroupperDispose, props, sys);\n    this._grouppers[newGroupper.id] = newGroupper;\n    const focusedElement = tabster.focusedElement.getFocusedElement(); // Newly created groupper contains currently focused element, update the state on the next tick (to\n    // make sure all grouppers are processed).\n\n    if (focusedElement && dom.nodeContains(element, focusedElement) && !this._updateTimer) {\n      this._updateTimer = this._win().setTimeout(() => {\n        delete this._updateTimer; // Making sure the focused element hasn't changed.\n\n        if (focusedElement === tabster.focusedElement.getFocusedElement()) {\n          this._updateCurrent(focusedElement);\n        }\n      }, 0);\n    }\n\n    return newGroupper;\n  }\n\n  forgetCurrentGrouppers() {\n    this._current = {};\n  }\n\n  _updateCurrent(element) {\n    var _a;\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      delete this._updateTimer;\n    }\n\n    const tabster = this._tabster;\n    const newIds = {};\n\n    for (let el = tabster.getParent(element); el; el = tabster.getParent(el)) {\n      const groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n\n      if (groupper) {\n        newIds[groupper.id] = true;\n        this._current[groupper.id] = groupper;\n        const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);\n        groupper.makeTabbable(isTabbable);\n      }\n    }\n\n    for (const id of Object.keys(this._current)) {\n      const groupper = this._current[id];\n\n      if (!(groupper.id in newIds)) {\n        groupper.makeTabbable(false);\n        groupper.setFirst(undefined);\n        delete this._current[id];\n      }\n    }\n  }\n\n  _enterGroupper(element, relatedEvent) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);\n    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n\n    if (groupper && groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {\n      const next = tabster.focusable.findNext({\n        container: groupperElement,\n        currentElement: element,\n        useActiveModalizer: true\n      });\n\n      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"groupper\",\n        owner: groupperElement,\n        next,\n        relatedEvent\n      })))) {\n        if (relatedEvent) {\n          // When the application hasn't prevented default,\n          // we consider the event completely handled, hence we\n          // prevent the initial event's default action and stop\n          // propagation.\n          relatedEvent.preventDefault();\n          relatedEvent.stopImmediatePropagation();\n        }\n\n        next.focus();\n        return next;\n      }\n    }\n\n    return null;\n  }\n\n  _escapeGroupper(element, relatedEvent, fromModalizer) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);\n    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n\n    if (groupper && groupperElement && dom.nodeContains(groupperElement, element)) {\n      let next;\n\n      if (element !== groupperElement || fromModalizer) {\n        next = groupper.getFirst(true);\n      } else {\n        const parentElement = dom.getParentElement(groupperElement);\n        const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : undefined;\n        groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n        next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n      }\n\n      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({\n        by: \"groupper\",\n        owner: groupperElement,\n        next,\n        relatedEvent\n      })))) {\n        if (groupper) {\n          groupper.makeTabbable(false);\n        } // This part happens asynchronously inside setTimeout,\n        // so no need to prevent default or stop propagation.\n\n\n        next.focus();\n        return next;\n      }\n    }\n\n    return null;\n  }\n\n  moveFocus(element, action) {\n    return action === GroupperMoveFocusActions.Enter ? this._enterGroupper(element) : this._escapeGroupper(element);\n  }\n\n  handleKeyPress(element, event, fromModalizer) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n\n    if (ctx && ((ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper))) {\n      tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);\n\n      if (ctx.ignoreKeydown(event)) {\n        return;\n      }\n\n      if (event.key === Keys.Enter) {\n        this._enterGroupper(element, event);\n      } else if (event.key === Keys.Escape) {\n        // We will handle Esc asynchronously, if something in the application will\n        // move focus during the keypress handling, we will not interfere.\n        const focusedElement = tabster.focusedElement.getFocusedElement();\n        tabster.focusedElement.requestAsyncFocus(AsyncFocusSources.EscapeGroupper, () => {\n          if (focusedElement !== tabster.focusedElement.getFocusedElement() && ( // A part of Modalizer that has called this handler to escape the active groupper\n          // might have been removed from DOM, if the focus is on body, we still want to handle Esc.\n          fromModalizer && !focusedElement || !fromModalizer)) {\n            // Something else in the application has moved focus, we will not handle Esc.\n            return;\n          }\n\n          this._escapeGroupper(element, event, fromModalizer);\n        }, 0);\n      }\n    }\n  }\n\n}\n\nfunction _setInformativeStyle$1(weakElement, remove) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-groupper\");\n      } else {\n        element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n      }\n    }\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass KeyboardNavigationState extends Subscribable {\n  constructor(getWindow) {\n    super();\n\n    this._onChange = isNavigatingWithKeyboard => {\n      this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    this._keyborg = createKeyborg(getWindow());\n\n    this._keyborg.subscribe(this._onChange);\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._keyborg) {\n      this._keyborg.unsubscribe(this._onChange);\n\n      disposeKeyborg(this._keyborg);\n      delete this._keyborg;\n    }\n  }\n\n  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {\n    var _a;\n\n    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);\n  }\n\n  isNavigatingWithKeyboard() {\n    var _a;\n\n    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nlet _wasFocusedCounter = 0;\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-modalizer\");\n      } else {\n        element.style.setProperty(\"--tabster-modalizer\", internalId + \",\" + userId + \",\" + (isActive ? \"active\" : \"inactive\") + \",\" + \",\" + (wasFocused ? `focused(${wasFocused})` : \"not-focused\"));\n      }\n    }\n  }\n}\n/**\r\n * Manages the dummy inputs for the Modalizer.\r\n */\n\n\nclass ModalizerDummyManager extends DummyInputManager {\n  constructor(element, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n    this._setHandlers((dummyInput, isBackward) => {\n      var _a, _b;\n\n      const el = element.get();\n      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());\n      const input = dummyInput.input;\n      let toFocus;\n\n      if (container && input) {\n        const dummyContainer = getDummyInputContainer(input);\n        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);\n\n        if (ctx) {\n          toFocus = (_b = FocusedElementState.findNextTabbable(tabster, ctx, container, input, undefined, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;\n        }\n\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    });\n  }\n\n}\n\nclass Modalizer extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys, activeElements) {\n    super(tabster, element, props);\n    this._wasFocused = 0;\n    this.userId = props.id;\n    this._onDispose = onDispose;\n    this._activeElements = activeElements;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n    }\n  }\n\n  makeActive(isActive) {\n    if (this._isActive !== isActive) {\n      this._isActive = isActive;\n      const element = this.getElement();\n\n      if (element) {\n        const activeElements = this._activeElements;\n        const index = activeElements.map(e => e.get()).indexOf(element);\n\n        if (isActive) {\n          if (index < 0) {\n            activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element));\n          }\n        } else {\n          if (index >= 0) {\n            activeElements.splice(index, 1);\n          }\n        }\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n      }\n\n      this._dispatchEvent(isActive);\n    }\n  }\n\n  focused(noIncrement) {\n    if (!noIncrement) {\n      this._wasFocused = ++_wasFocusedCounter;\n    }\n\n    return this._wasFocused;\n  }\n\n  setProps(props) {\n    if (props.id) {\n      this.userId = props.id;\n    }\n\n    this._props = { ...props\n    };\n  }\n\n  dispose() {\n    var _a;\n\n    this.makeActive(false);\n\n    this._onDispose(this);\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    delete this.dummyManager;\n    this._activeElements = [];\n\n    this._remove();\n  }\n\n  isActive() {\n    return !!this._isActive;\n  }\n\n  contains(element) {\n    return dom.nodeContains(this.getElement(), element);\n  }\n\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    var _a, _b;\n\n    const modalizerElement = this.getElement();\n\n    if (!modalizerElement) {\n      return null;\n    }\n\n    const tabster = this._tabster;\n    let next = null;\n    let outOfDOMOrder = false;\n    let uncontrolled;\n    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());\n\n    if (container) {\n      const findProps = {\n        container,\n        currentElement,\n        referenceElement,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n\n      if (!next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }, findPropsOut);\n\n        if (next === null) {\n          next = currentElement;\n        }\n\n        outOfDOMOrder = true;\n      } else {\n        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n      }\n\n      uncontrolled = findPropsOut.uncontrolled;\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n\n  _dispatchEvent(isActive, allElements) {\n    const element = this.getElement();\n    let defaultPrevented = false;\n\n    if (element) {\n      const elements = allElements ? this._activeElements.map(e => e.get()) : [element];\n\n      for (const el of elements) {\n        if (el) {\n          const eventDetail = {\n            id: this.userId,\n            element\n          };\n          const event = isActive ? new ModalizerActiveEvent(eventDetail) : new ModalizerInactiveEvent(eventDetail);\n          el.dispatchEvent(event);\n\n          if (event.defaultPrevented) {\n            defaultPrevented = true;\n          }\n        }\n      }\n    }\n\n    return defaultPrevented;\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass ModalizerAPI {\n  constructor(tabster, // @deprecated use accessibleCheck.\n  alwaysAccessibleSelector, accessibleCheck) {\n    this._onModalizerDispose = modalizer => {\n      const id = modalizer.id;\n      const userId = modalizer.userId;\n      const part = this._parts[userId];\n      delete this._modalizers[id];\n\n      if (part) {\n        delete part[id];\n\n        if (Object.keys(part).length === 0) {\n          delete this._parts[userId];\n          const activationHistory = this._activationHistory;\n          const cleanActivationHistory = [];\n          let prevHistoryItem; // The history order is from most recent to oldest.\n\n          for (let i = activationHistory.length; i--;) {\n            // Remove from activation history, making sure there are no duplicates\n            // for cases like [modal2, modal1, modal2, modal1]: just removing modal2\n            // will result in [modal1, modal1] and we want just [modal1]. Otherwise,\n            // there is a chance for this array to grow forever in a narrow case of\n            // a modalizer that stays in DOM forever and is being activated/deactivated\n            // switching between other modalizers that come and go.\n            const modalizerUserIdFromHistory = activationHistory[i];\n\n            if (modalizerUserIdFromHistory === userId) {\n              continue;\n            }\n\n            if (modalizerUserIdFromHistory !== prevHistoryItem) {\n              prevHistoryItem = modalizerUserIdFromHistory;\n\n              if (modalizerUserIdFromHistory || cleanActivationHistory.length > 0) {\n                cleanActivationHistory.unshift(modalizerUserIdFromHistory);\n              }\n            }\n          }\n\n          this._activationHistory = cleanActivationHistory;\n\n          if (this.activeId === userId) {\n            const prevActiveId = cleanActivationHistory[0];\n            const prevActive = prevActiveId ? Object.values(this._parts[prevActiveId])[0] : undefined;\n            this.setActive(prevActive);\n          }\n        }\n      }\n    };\n\n    this._onKeyDown = event => {\n      var _a;\n\n      if (event.key !== Keys.Escape) {\n        return;\n      }\n\n      const tabster = this._tabster;\n      const element = tabster.focusedElement.getFocusedElement();\n\n      if (element) {\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n\n        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {\n          const activeId = modalizer.userId;\n\n          if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n              const focusedSince = Object.keys(part).map(id => {\n                var _a;\n\n                const m = part[id];\n                const el = m.getElement();\n                let groupper;\n\n                if (el) {\n                  groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n                }\n\n                return m && el && groupper ? {\n                  el,\n                  focusedSince: m.focused(true)\n                } : {\n                  focusedSince: 0\n                };\n              }).filter(f => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);\n\n              if (focusedSince.length) {\n                const groupperElement = focusedSince[0].el;\n\n                if (groupperElement) {\n                  (_a = tabster.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n    /**\r\n     * Subscribes to the focus state and handles modalizer related focus events\r\n     * @param focusedElement - Element that is focused\r\n     * @param detail - Additional data about the focus event\r\n     */\n\n\n    this._onFocus = (focusedElement, detail) => {\n      var _a;\n\n      const tabster = this._tabster;\n      const ctx = focusedElement && RootAPI.getTabsterContext(tabster, focusedElement); // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n\n      if (!ctx || !focusedElement) {\n        return;\n      }\n\n      const augmentedMap = this._augMap;\n\n      for (let e = focusedElement; e; e = tabster.getParent(e)) {\n        // If the newly focused element is inside some of the hidden containers,\n        // remove aria-hidden from those synchronously for the screen readers\n        // to be able to read the element. The rest of aria-hiddens, will be removed\n        // acynchronously for the sake of performance.\n        if (augmentedMap.has(e)) {\n          augmentedMap.delete(e);\n          augmentAttribute(tabster, e, _ariaHidden);\n        }\n      }\n\n      let modalizer = ctx.modalizer;\n      const tabsterOnFocusedElement = getTabsterOnElement(tabster, focusedElement);\n      const modalizerOnFocusedElement = tabsterOnFocusedElement === null || tabsterOnFocusedElement === void 0 ? void 0 : tabsterOnFocusedElement.modalizer;\n\n      if (modalizerOnFocusedElement) {\n        modalizerOnFocusedElement.focused();\n\n        if (modalizerOnFocusedElement.userId === this.activeId && tabsterOnFocusedElement.groupper) {\n          const parentElement = tabster.getParent(focusedElement);\n          const parentModalizer = parentElement && ((_a = RootAPI.getTabsterContext(tabster, parentElement)) === null || _a === void 0 ? void 0 : _a.modalizer);\n\n          if (parentModalizer) {\n            modalizer = parentModalizer;\n          } else {\n            this.setActive(undefined);\n            return;\n          }\n        }\n      } // An inactive groupper with the modalizer on the same node will not give the modalizer\n      // in the context, yet we still want to track that the modalizer's container was focused.\n\n\n      modalizer === null || modalizer === void 0 ? void 0 : modalizer.focused();\n\n      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {\n        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n        return;\n      } // Developers calling `element.focus()` should change/deactivate active modalizer\n\n\n      if (detail.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {\n        this.setActive(modalizer);\n      } else {\n        // Focused outside of the active modalizer, try pull focus back to current modalizer\n        const win = this._win();\n\n        win.clearTimeout(this._restoreModalizerFocusTimer); // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n        // Figure out a better way of doing this rather than a 100ms timeout\n\n        this._restoreModalizerFocusTimer = win.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._modalizers = {};\n    this._parts = {};\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n    this._accessibleCheck = accessibleCheck;\n    this._activationHistory = [];\n    this.activeElements = [];\n\n    if (!tabster.controlTab) {\n      tabster.root.addDummyInputs();\n    }\n\n    const win = this._win();\n\n    win.addEventListener(\"keydown\", this._onKeyDown, true);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n\n  dispose() {\n    const win = this._win();\n\n    win.removeEventListener(\"keydown\", this._onKeyDown, true); // Dispose all modalizers managed by the API\n\n    Object.keys(this._modalizers).forEach(modalizerId => {\n      if (this._modalizers[modalizerId]) {\n        this._modalizers[modalizerId].dispose();\n\n        delete this._modalizers[modalizerId];\n      }\n    });\n    win.clearTimeout(this._restoreModalizerFocusTimer);\n    win.clearTimeout(this._hiddenUpdateTimer);\n    this._parts = {};\n    delete this.activeId;\n    this.activeElements = [];\n    this._augMap = new WeakMap();\n    this._aug = [];\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n  }\n\n  createModalizer(element, props, sys) {\n    var _a;\n\n    if (process.env.NODE_ENV === 'development') ;\n\n    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);\n    const id = modalizer.id;\n    const userId = props.id;\n    this._modalizers[id] = modalizer;\n    let part = this._parts[userId];\n\n    if (!part) {\n      part = this._parts[userId] = {};\n    }\n\n    part[id] = modalizer;\n    const focusedElement = (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null; // Adding a modalizer which is already focused, activate it\n\n    if (element !== focusedElement && dom.nodeContains(element, focusedElement)) {\n      if (userId !== this.activeId) {\n        this.setActive(modalizer);\n      } else {\n        modalizer.makeActive(true);\n      }\n    }\n\n    return modalizer;\n  }\n\n  isAugmented(element) {\n    return this._augMap.has(element);\n  }\n\n  hiddenUpdate() {\n    if (this._hiddenUpdateTimer) {\n      return;\n    }\n\n    this._hiddenUpdateTimer = this._win().setTimeout(() => {\n      delete this._hiddenUpdateTimer;\n\n      this._hiddenUpdate();\n    }, 250);\n  }\n\n  setActive(modalizer) {\n    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;\n    const activeId = this.activeId;\n\n    if (activeId === userId) {\n      return;\n    }\n\n    this.activeId = userId;\n\n    if (activeId) {\n      const part = this._parts[activeId];\n\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(false);\n        }\n      }\n    }\n\n    if (userId) {\n      const part = this._parts[userId];\n\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(true);\n        }\n      }\n    }\n\n    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n    this.hiddenUpdate();\n    const activationHistory = this._activationHistory;\n\n    if (activationHistory[0] !== userId && (userId !== undefined || activationHistory.length > 0)) {\n      activationHistory.unshift(userId);\n    }\n  }\n\n  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, elementFromModalizer);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n\n    if (modalizer) {\n      this.setActive(modalizer);\n      const props = modalizer.getProps();\n      const modalizerRoot = modalizer.getElement();\n\n      if (modalizerRoot) {\n        if (noFocusFirst === undefined) {\n          noFocusFirst = props.isNoFocusFirst;\n        }\n\n        if (!noFocusFirst && tabster.keyboardNavigation.isNavigatingWithKeyboard() && tabster.focusedElement.focusFirst({\n          container: modalizerRoot\n        })) {\n          return true;\n        }\n\n        if (noFocusDefault === undefined) {\n          noFocusDefault = props.isNoFocusDefault;\n        }\n\n        if (!noFocusDefault && tabster.focusedElement.focusDefault(modalizerRoot)) {\n          return true;\n        }\n\n        tabster.focusedElement.resetFocus(modalizerRoot);\n      }\n    } else if (process.env.NODE_ENV === 'development') {\n      console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n    }\n\n    return false;\n  }\n\n  activate(modalizerElementOrContainer) {\n    var _a;\n\n    const modalizerToActivate = modalizerElementOrContainer ? (_a = RootAPI.getTabsterContext(this._tabster, modalizerElementOrContainer)) === null || _a === void 0 ? void 0 : _a.modalizer : undefined;\n\n    if (!modalizerElementOrContainer || modalizerToActivate) {\n      this.setActive(modalizerToActivate);\n      return true;\n    }\n\n    return false;\n  }\n\n  acceptElement(element, state) {\n    var _a;\n\n    const modalizerUserId = state.modalizerUserId;\n    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;\n\n    if (modalizerUserId) {\n      for (const e of this.activeElements) {\n        const el = e.get();\n\n        if (el && (dom.nodeContains(element, el) || el === element)) {\n          // We have a part of currently active modalizer somewhere deeper in the DOM,\n          // skipping all other checks.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n    }\n\n    const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? undefined : NodeFilter.FILTER_SKIP;\n\n    if (ret !== undefined) {\n      state.skippedFocusable = true;\n    }\n\n    return ret;\n  }\n\n  _hiddenUpdate() {\n    var _a;\n\n    const tabster = this._tabster;\n    const body = tabster.getWindow().document.body;\n    const activeId = this.activeId;\n    const parts = this._parts;\n    const visibleElements = [];\n    const hiddenElements = [];\n    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(dom.querySelectorAll(body, alwaysAccessibleSelector)) : [];\n    const activeModalizerElements = [];\n\n    for (const userId of Object.keys(parts)) {\n      const modalizerParts = parts[userId];\n\n      for (const id of Object.keys(modalizerParts)) {\n        const modalizer = modalizerParts[id];\n        const el = modalizer.getElement();\n        const props = modalizer.getProps();\n        const isAlwaysAccessible = props.isAlwaysAccessible;\n\n        if (el) {\n          if (userId === activeId) {\n            activeModalizerElements.push(el);\n\n            if (!this.currentIsOthersAccessible) {\n              visibleElements.push(el);\n            }\n          } else if (isAlwaysAccessible) {\n            alwaysAccessibleElements.push(el);\n          } else {\n            hiddenElements.push(el);\n          }\n        }\n      }\n    }\n\n    const augmentedMap = this._augMap;\n    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : undefined;\n    const newAugmented = [];\n    const newAugmentedMap = new WeakMap();\n\n    const toggle = (element, hide) => {\n      var _a;\n\n      const tagName = element.tagName;\n\n      if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n        return;\n      }\n\n      let isAugmented = false;\n\n      if (augmentedMap.has(element)) {\n        if (hide) {\n          isAugmented = true;\n        } else {\n          augmentedMap.delete(element);\n          augmentAttribute(tabster, element, _ariaHidden);\n        }\n      } else if (hide && !((_a = this._accessibleCheck) === null || _a === void 0 ? void 0 : _a.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, \"true\")) {\n        augmentedMap.set(element, true);\n        isAugmented = true;\n      }\n\n      if (isAugmented) {\n        newAugmented.push(new WeakHTMLElement(tabster.getWindow, element));\n        newAugmentedMap.set(element, true);\n      }\n    };\n\n    const walk = element => {\n      var _a;\n\n      for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {\n        let skip = false;\n        let containsModalizer = false;\n        let containedByModalizer = false;\n\n        if (allVisibleElements) {\n          const elParent = tabster.getParent(el);\n\n          for (const c of allVisibleElements) {\n            if (el === c) {\n              skip = true;\n              break;\n            }\n\n            if (dom.nodeContains(el, c)) {\n              containsModalizer = true;\n              break;\n            } else if (dom.nodeContains(c, elParent)) {\n              // tabster.getParent() could be provided by the application to\n              // handle, for example, virtual parents. Making sure, we are\n              // not setting aria-hidden on elements which are virtually\n              // inside modalizer.\n              containedByModalizer = true;\n            }\n          }\n\n          if (containsModalizer || ((_a = el.__tabsterElementFlags) === null || _a === void 0 ? void 0 : _a.noDirectAriaHidden)) {\n            walk(el);\n          } else if (!skip && !containedByModalizer) {\n            toggle(el, true);\n          }\n        } else {\n          toggle(el, false);\n        }\n      }\n    };\n\n    if (!allVisibleElements) {\n      alwaysAccessibleElements.forEach(e => toggle(e, false));\n    }\n\n    hiddenElements.forEach(e => toggle(e, true));\n\n    if (body) {\n      walk(body);\n    }\n\n    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map(e => e.get()).forEach(e => {\n      if (e && !newAugmentedMap.get(e)) {\n        toggle(e, false);\n      }\n    });\n    this._aug = newAugmented;\n    this._augMap = newAugmentedMap;\n  }\n  /**\r\n   * Called when an element is focused outside of an active modalizer.\r\n   * Attempts to pull focus back into the active modalizer\r\n   * @param outsideElement - An element being focused outside of the modalizer\r\n   */\n\n\n  _restoreModalizerFocus(outsideElement) {\n    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;\n\n    if (!outsideElement || !ownerDocument) {\n      return;\n    }\n\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, outsideElement);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    const activeId = this.activeId;\n\n    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {\n      return;\n    }\n\n    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();\n\n    if (container) {\n      let toFocus = tabster.focusable.findFirst({\n        container,\n        useActiveModalizer: true\n      });\n\n      if (toFocus) {\n        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {\n          toFocus = tabster.focusable.findLast({\n            container,\n            useActiveModalizer: true\n          });\n\n          if (!toFocus) {\n            // This only might mean that findFirst/findLast are buggy and inconsistent.\n            throw new Error(\"Something went wrong.\");\n          }\n        }\n\n        tabster.focusedElement.focus(toFocus);\n        return;\n      }\n    } // Current Modalizer doesn't seem to have focusable elements.\n    // Blurring the currently focused element which is outside of the current Modalizer.\n\n\n    outsideElement.blur();\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nconst _inputSelector = /*#__PURE__*/[\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n  constructor(element, tabster, getMemorized, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n    this._onFocusDummyInput = dummyInput => {\n      var _a, _b;\n\n      const container = this._element.get();\n\n      const input = dummyInput.input;\n\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, container);\n        let toFocus;\n\n        if (ctx) {\n          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, undefined, input, undefined, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;\n        }\n\n        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();\n\n        if (memorized && this._tabster.focusable.isFocusable(memorized)) {\n          toFocus = memorized;\n        }\n\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    };\n\n    this._tabster = tabster;\n    this._getMemorized = getMemorized;\n\n    this._setHandlers(this._onFocusDummyInput);\n  }\n\n} // TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\n\n\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\nclass Mover extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    var _a;\n\n    super(tabster, element, props);\n    this._visible = {};\n\n    this._onIntersection = entries => {\n      for (const entry of entries) {\n        const el = entry.target;\n        const id = getElementUId(this._win, el);\n        let newVisibility;\n        let fullyVisible = this._fullyVisible;\n\n        if (entry.intersectionRatio >= 0.25) {\n          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;\n\n          if (newVisibility === Visibilities.Visible) {\n            fullyVisible = id;\n          }\n        } else {\n          newVisibility = Visibilities.Invisible;\n        }\n\n        if (this._visible[id] !== newVisibility) {\n          if (newVisibility === undefined) {\n            delete this._visible[id];\n\n            if (fullyVisible === id) {\n              delete this._fullyVisible;\n            }\n          } else {\n            this._visible[id] = newVisibility;\n            this._fullyVisible = fullyVisible;\n          }\n\n          const state = this.getState(el);\n\n          if (state) {\n            el.dispatchEvent(new MoverStateEvent(state));\n          }\n        }\n      }\n    };\n\n    this._win = tabster.getWindow;\n    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;\n\n    if (this._props.trackState || this._props.visibilityAware) {\n      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {\n        threshold: [0, 0.25, 0.5, 0.75, 1]\n      });\n\n      this._observeState();\n    }\n\n    this._onDispose = onDispose;\n\n    const getMemorized = () => props.memorizeCurrent ? this._current : undefined;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n\n      delete this._intersectionObserver;\n    }\n\n    delete this._current;\n    delete this._fullyVisible;\n    delete this._allElements;\n    delete this._updateQueue;\n\n    if (this._unobserve) {\n      this._unobserve();\n\n      delete this._unobserve;\n    }\n\n    const win = this._win();\n\n    if (this._setCurrentTimer) {\n      win.clearTimeout(this._setCurrentTimer);\n      delete this._setCurrentTimer;\n    }\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    delete this.dummyManager;\n  }\n\n  setCurrent(element) {\n    if (element) {\n      this._current = new WeakHTMLElement(this._win, element);\n    } else {\n      this._current = undefined;\n    }\n\n    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {\n      this._setCurrentTimer = this._win().setTimeout(() => {\n        var _a;\n\n        delete this._setCurrentTimer;\n        const changed = [];\n\n        if (this._current !== this._prevCurrent) {\n          changed.push(this._current);\n          changed.push(this._prevCurrent);\n          this._prevCurrent = this._current;\n        }\n\n        for (const weak of changed) {\n          const el = weak === null || weak === void 0 ? void 0 : weak.get();\n\n          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {\n            const props = this._props;\n\n            if (el && (props.visibilityAware !== undefined || props.trackState)) {\n              const state = this.getState(el);\n\n              if (state) {\n                el.dispatchEvent(new MoverStateEvent(state));\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n\n  getCurrent() {\n    var _a;\n\n    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;\n  }\n\n  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {\n    const container = this.getElement();\n    const currentIsDummy = container && getDummyInputContainer(currentElement) === container;\n\n    if (!container) {\n      return null;\n    }\n\n    let next = null;\n    let outOfDOMOrder = false;\n    let uncontrolled;\n\n    if (this._props.tabbable || currentIsDummy || currentElement && !dom.nodeContains(container, currentElement)) {\n      const findProps = {\n        currentElement,\n        referenceElement,\n        container,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      };\n      const findPropsOut = {};\n      next = this._tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](findProps, findPropsOut);\n      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n      uncontrolled = findPropsOut.uncontrolled;\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      outOfDOMOrder\n    };\n  }\n\n  acceptElement(element, state) {\n    var _a, _b;\n\n    if (!FocusedElementState.isTabbing) {\n      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.excludedFromMover) ? NodeFilter.FILTER_REJECT : undefined;\n    }\n\n    const {\n      memorizeCurrent,\n      visibilityAware,\n      hasDefault = true\n    } = this._props;\n    const moverElement = this.getElement();\n\n    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!dom.nodeContains(moverElement, state.from) || getDummyInputContainer(state.from) === moverElement)) {\n      let found;\n\n      if (memorizeCurrent) {\n        const current = (_b = this._current) === null || _b === void 0 ? void 0 : _b.get();\n\n        if (current && state.acceptCondition(current)) {\n          found = current;\n        }\n      }\n\n      if (!found && hasDefault) {\n        found = this._tabster.focusable.findDefault({\n          container: moverElement,\n          useActiveModalizer: true\n        });\n      }\n\n      if (!found && visibilityAware) {\n        found = this._tabster.focusable.findElement({\n          container: moverElement,\n          useActiveModalizer: true,\n          isBackward: state.isBackward,\n          acceptCondition: el => {\n            var _a;\n\n            const id = getElementUId(this._win, el);\n            const visibility = this._visible[id];\n            return moverElement !== el && !!((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));\n          }\n        });\n      }\n\n      if (found) {\n        state.found = true;\n        state.foundElement = found;\n        state.rejectElementsFrom = moverElement;\n        state.skippedFocusable = true;\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n\n    return undefined;\n  }\n\n  _observeState() {\n    const element = this.getElement();\n\n    if (this._unobserve || !element || typeof MutationObserver === \"undefined\") {\n      return;\n    }\n\n    const win = this._win();\n\n    const allElements = this._allElements = new WeakMap();\n    const tabsterFocusable = this._tabster.focusable;\n    let updateQueue = this._updateQueue = [];\n    const observer = dom.createMutationObserver(mutations => {\n      for (const mutation of mutations) {\n        const target = mutation.target;\n        const removed = mutation.removedNodes;\n        const added = mutation.addedNodes;\n\n        if (mutation.type === \"attributes\") {\n          if (mutation.attributeName === \"tabindex\") {\n            updateQueue.push({\n              element: target,\n              type: _moverUpdateAttr\n            });\n          }\n        } else {\n          for (let i = 0; i < removed.length; i++) {\n            updateQueue.push({\n              element: removed[i],\n              type: _moverUpdateRemove\n            });\n          }\n\n          for (let i = 0; i < added.length; i++) {\n            updateQueue.push({\n              element: added[i],\n              type: _moverUpdateAdd\n            });\n          }\n        }\n      }\n\n      requestUpdate();\n    });\n\n    const setElement = (element, remove) => {\n      var _a, _b;\n\n      const current = allElements.get(element);\n\n      if (current && remove) {\n        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element);\n        allElements.delete(element);\n      }\n\n      if (!current && !remove) {\n        allElements.set(element, this);\n        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element);\n      }\n    };\n\n    const updateElement = element => {\n      const isFocusable = tabsterFocusable.isFocusable(element);\n      const current = allElements.get(element);\n\n      if (current) {\n        if (!isFocusable) {\n          setElement(element, true);\n        }\n      } else {\n        if (isFocusable) {\n          setElement(element);\n        }\n      }\n    };\n\n    const addNewElements = element => {\n      const {\n        mover\n      } = getMoverGroupper(element);\n\n      if (mover && mover !== this) {\n        if (mover.getElement() === element && tabsterFocusable.isFocusable(element)) {\n          setElement(element);\n        } else {\n          return;\n        }\n      }\n\n      const walker = createElementTreeWalker(win.document, element, node => {\n        const {\n          mover,\n          groupper\n        } = getMoverGroupper(node);\n\n        if (mover && mover !== this) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n\n        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if (tabsterFocusable.isFocusable(node)) {\n          setElement(node);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      });\n\n      if (walker) {\n        walker.currentNode = element;\n\n        while (walker.nextNode()) {\n          /* Iterating for the sake of calling processNode() callback. */\n        }\n      }\n    };\n\n    const removeWalk = element => {\n      const current = allElements.get(element);\n\n      if (current) {\n        setElement(element, true);\n      }\n\n      for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {\n        removeWalk(el);\n      }\n    };\n\n    const requestUpdate = () => {\n      if (!this._updateTimer && updateQueue.length) {\n        this._updateTimer = win.setTimeout(() => {\n          delete this._updateTimer;\n\n          for (const {\n            element,\n            type\n          } of updateQueue) {\n            switch (type) {\n              case _moverUpdateAttr:\n                updateElement(element);\n                break;\n\n              case _moverUpdateAdd:\n                addNewElements(element);\n                break;\n\n              case _moverUpdateRemove:\n                removeWalk(element);\n                break;\n            }\n          }\n\n          updateQueue = this._updateQueue = [];\n        }, 0);\n      }\n    };\n\n    const getMoverGroupper = element => {\n      const ret = {};\n\n      for (let el = element; el; el = dom.getParentElement(el)) {\n        const toe = getTabsterOnElement(this._tabster, el);\n\n        if (toe) {\n          if (toe.groupper && !ret.groupper) {\n            ret.groupper = toe.groupper;\n          }\n\n          if (toe.mover) {\n            ret.mover = toe.mover;\n            break;\n          }\n        }\n      }\n\n      return ret;\n    };\n\n    updateQueue.push({\n      element,\n      type: _moverUpdateAdd\n    });\n    requestUpdate();\n    observer.observe(element, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"tabindex\"]\n    });\n\n    this._unobserve = () => {\n      observer.disconnect();\n    };\n  }\n\n  getState(element) {\n    const id = getElementUId(this._win, element);\n\n    if (id in this._visible) {\n      const visibility = this._visible[id] || Visibilities.Invisible;\n      const isCurrent = this._current ? this._current.get() === element : undefined;\n      return {\n        isCurrent,\n        visibility\n      };\n    }\n\n    return undefined;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n/**\r\n * Calculates distance between two rectangles.\r\n *\r\n * @param ax1 first rectangle left\r\n * @param ay1 first rectangle top\r\n * @param ax2 first rectangle right\r\n * @param ay2 first rectangle bottom\r\n * @param bx1 second rectangle left\r\n * @param by1 second rectangle top\r\n * @param bx2 second rectangle right\r\n * @param by2 second rectangle bottom\r\n * @returns number, shortest distance between the rectangles.\r\n */\n\n\nfunction getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nclass MoverAPI {\n  constructor(tabster, getWindow) {\n    this._init = () => {\n      const win = this._win();\n\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      win.addEventListener(MoverMoveFocusEventName, this._onMoveFocus);\n      win.addEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);\n\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    this._onMoverDispose = mover => {\n      delete this._movers[mover.id];\n    };\n\n    this._onFocus = element => {\n      var _a; // When something in the app gets focused, we are making sure that\n      // the relevant context Mover is aware of it.\n      // Looking for the relevant context Mover from the currently\n      // focused element parent, not from the element itself, because the\n      // Mover element itself cannot be its own current (but might be\n      // current for its parent Mover).\n\n\n      let currentFocusableElement = element;\n      let deepestFocusableElement = element;\n\n      for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {\n        // We go through all Movers up from the focused element and\n        // set their current element to the deepest focusable of that\n        // Mover.\n        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;\n\n        if (mover) {\n          mover.setCurrent(deepestFocusableElement);\n          currentFocusableElement = undefined;\n        }\n\n        if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) {\n          currentFocusableElement = deepestFocusableElement = el;\n        }\n      }\n    };\n\n    this._onKeyDown = async event => {\n      var _a;\n\n      if (this._ignoredInputTimer) {\n        this._win().clearTimeout(this._ignoredInputTimer);\n\n        delete this._ignoredInputTimer;\n      }\n\n      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false); // Give a chance to other listeners to handle the event (for example,\n      // to scroll instead of moving focus).\n\n      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n        return;\n      }\n\n      const key = event.key;\n      let moverKey;\n\n      if (key === Keys.ArrowDown) {\n        moverKey = MoverKeys.ArrowDown;\n      } else if (key === Keys.ArrowRight) {\n        moverKey = MoverKeys.ArrowRight;\n      } else if (key === Keys.ArrowUp) {\n        moverKey = MoverKeys.ArrowUp;\n      } else if (key === Keys.ArrowLeft) {\n        moverKey = MoverKeys.ArrowLeft;\n      } else if (key === Keys.PageDown) {\n        moverKey = MoverKeys.PageDown;\n      } else if (key === Keys.PageUp) {\n        moverKey = MoverKeys.PageUp;\n      } else if (key === Keys.Home) {\n        moverKey = MoverKeys.Home;\n      } else if (key === Keys.End) {\n        moverKey = MoverKeys.End;\n      }\n\n      if (!moverKey) {\n        return;\n      }\n\n      const focused = this._tabster.focusedElement.getFocusedElement();\n\n      if (!focused || (await this._isIgnoredInput(focused, key))) {\n        return;\n      }\n\n      this._moveFocus(focused, moverKey, event);\n    };\n\n    this._onMoveFocus = e => {\n      var _a;\n\n      const element = e.composedPath()[0];\n      const key = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.key;\n\n      if (element && key !== undefined && !e.defaultPrevented) {\n        this._moveFocus(element, key);\n\n        e.stopImmediatePropagation();\n      }\n    };\n\n    this._onMemorizedElement = e => {\n      var _a;\n\n      const target = e.composedPath()[0];\n      let memorizedElement = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.memorizedElement;\n\n      if (target) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, target);\n        const mover = ctx === null || ctx === void 0 ? void 0 : ctx.mover;\n\n        if (mover) {\n          if (memorizedElement && !dom.nodeContains(mover.getElement(), memorizedElement)) {\n            memorizedElement = undefined;\n          }\n\n          mover.setCurrent(memorizedElement);\n          e.stopImmediatePropagation();\n        }\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    this._movers = {};\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    var _a;\n\n    const win = this._win();\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n\n    if (this._ignoredInputTimer) {\n      win.clearTimeout(this._ignoredInputTimer);\n      delete this._ignoredInputTimer;\n    }\n\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    win.removeEventListener(MoverMoveFocusEventName, this._onMoveFocus);\n    win.removeEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);\n    Object.keys(this._movers).forEach(moverId => {\n      if (this._movers[moverId]) {\n        this._movers[moverId].dispose();\n\n        delete this._movers[moverId];\n      }\n    });\n  }\n\n  createMover(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);\n    this._movers[newMover.id] = newMover;\n    return newMover;\n  }\n\n  moveFocus(fromElement, key) {\n    return this._moveFocus(fromElement, key);\n  }\n\n  _moveFocus(fromElement, key, relatedEvent) {\n    var _a, _b;\n\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, fromElement, {\n      checkRtl: true\n    });\n\n    if (!ctx || !ctx.mover || ctx.excludedFromMover || relatedEvent && ctx.ignoreKeydown(relatedEvent)) {\n      return null;\n    }\n\n    const mover = ctx.mover;\n    const container = mover.getElement();\n\n    if (ctx.groupperBeforeMover) {\n      const groupper = ctx.groupper;\n\n      if (groupper && !groupper.isActive(true)) {\n        // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n        // the grouppers between the current element and the current mover.\n        for (let el = dom.getParentElement(groupper.getElement()); el && el !== container; el = dom.getParentElement(el)) {\n          if ((_b = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper) === null || _b === void 0 ? void 0 : _b.isActive(true)) {\n            return null;\n          }\n        }\n      } else {\n        return null;\n      }\n    }\n\n    if (!container) {\n      return null;\n    }\n\n    const focusable = tabster.focusable;\n    const moverProps = mover.getProps();\n    const direction = moverProps.direction || MoverDirections.Both;\n    const isBoth = direction === MoverDirections.Both;\n    const isVertical = isBoth || direction === MoverDirections.Vertical;\n    const isHorizontal = isBoth || direction === MoverDirections.Horizontal;\n    const isGridLinear = direction === MoverDirections.GridLinear;\n    const isGrid = isGridLinear || direction === MoverDirections.Grid;\n    const isCyclic = moverProps.cyclic;\n    let next;\n    let scrollIntoViewArg;\n    let focusedElementRect;\n    let focusedElementX1 = 0;\n    let focusedElementX2 = 0;\n\n    if (isGrid) {\n      focusedElementRect = fromElement.getBoundingClientRect();\n      focusedElementX1 = Math.ceil(focusedElementRect.left);\n      focusedElementX2 = Math.floor(focusedElementRect.right);\n    }\n\n    if (ctx.rtl) {\n      if (key === MoverKeys.ArrowRight) {\n        key = MoverKeys.ArrowLeft;\n      } else if (key === MoverKeys.ArrowLeft) {\n        key = MoverKeys.ArrowRight;\n      }\n    }\n\n    if (key === MoverKeys.ArrowDown && isVertical || key === MoverKeys.ArrowRight && (isHorizontal || isGrid)) {\n      next = focusable.findNext({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true\n      });\n\n      if (next && isGrid) {\n        const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);\n\n        if (!isGridLinear && focusedElementX2 > nextElementX1) {\n          next = undefined;\n        }\n      } else if (!next && isCyclic) {\n        next = focusable.findFirst({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.ArrowUp && isVertical || key === MoverKeys.ArrowLeft && (isHorizontal || isGrid)) {\n      next = focusable.findPrev({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true\n      });\n\n      if (next && isGrid) {\n        const nextElementX2 = Math.floor(next.getBoundingClientRect().right);\n\n        if (!isGridLinear && nextElementX2 > focusedElementX1) {\n          next = undefined;\n        }\n      } else if (!next && isCyclic) {\n        next = focusable.findLast({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.Home) {\n      if (isGrid) {\n        focusable.findElement({\n          container,\n          currentElement: fromElement,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            var _a;\n\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n\n            if (el !== fromElement && focusedElementX1 <= nextElementX1) {\n              return true;\n            }\n\n            next = el;\n            return false;\n          }\n        });\n      } else {\n        next = focusable.findFirst({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.End) {\n      if (isGrid) {\n        focusable.findElement({\n          container,\n          currentElement: fromElement,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            var _a;\n\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n\n            if (el !== fromElement && focusedElementX1 >= nextElementX1) {\n              return true;\n            }\n\n            next = el;\n            return false;\n          }\n        });\n      } else {\n        next = focusable.findLast({\n          container,\n          useActiveModalizer: true\n        });\n      }\n    } else if (key === MoverKeys.PageUp) {\n      focusable.findElement({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true,\n        isBackward: true,\n        acceptCondition: el => {\n          if (!focusable.isFocusable(el)) {\n            return false;\n          }\n\n          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n            next = el;\n            return false;\n          }\n\n          return true;\n        }\n      }); // will be on the first column move forward and preserve previous column\n\n      if (isGrid && next) {\n        const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n        focusable.findElement({\n          currentElement: next,\n          container,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n\n            if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {\n              return true;\n            }\n\n            next = el;\n            return false;\n          }\n        });\n      }\n\n      scrollIntoViewArg = false;\n    } else if (key === MoverKeys.PageDown) {\n      focusable.findElement({\n        currentElement: fromElement,\n        container,\n        useActiveModalizer: true,\n        acceptCondition: el => {\n          if (!focusable.isFocusable(el)) {\n            return false;\n          }\n\n          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n            next = el;\n            return false;\n          }\n\n          return true;\n        }\n      }); // will be on the last column move backwards and preserve previous column\n\n      if (isGrid && next) {\n        const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n        focusable.findElement({\n          currentElement: next,\n          container,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n\n            if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {\n              return true;\n            }\n\n            next = el;\n            return false;\n          }\n        });\n      }\n\n      scrollIntoViewArg = true;\n    } else if (isGrid) {\n      const isBackward = key === MoverKeys.ArrowUp;\n      const ax1 = focusedElementX1; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      const ay1 = Math.ceil(focusedElementRect.top);\n      const ax2 = focusedElementX2; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      const ay2 = Math.floor(focusedElementRect.bottom);\n      let targetElement;\n      let lastDistance;\n      let lastIntersection = 0;\n      focusable.findAll({\n        container,\n        currentElement: fromElement,\n        isBackward,\n        onElement: el => {\n          // Find element which has maximal intersection with the focused element horizontally,\n          // or the closest one.\n          const rect = el.getBoundingClientRect();\n          const bx1 = Math.ceil(rect.left);\n          const by1 = Math.ceil(rect.top);\n          const bx2 = Math.floor(rect.right);\n          const by2 = Math.floor(rect.bottom);\n\n          if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {\n            // Only consider elements which are below/above curretly focused.\n            return true;\n          }\n\n          const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));\n          const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n          if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {\n            // Element intersects with the focused element on X axis.\n            const intersection = xIntersectionWidth / minWidth;\n\n            if (intersection > lastIntersection) {\n              targetElement = el;\n              lastIntersection = intersection;\n            }\n          } else if (lastIntersection === 0) {\n            // If we didn't have intersection, try just the closest one.\n            const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);\n\n            if (lastDistance === undefined || distance < lastDistance) {\n              lastDistance = distance;\n              targetElement = el;\n            }\n          } else if (lastIntersection > 0) {\n            // Element doesn't intersect, but we had intersection already, stop search.\n            return false;\n          }\n\n          return true;\n        }\n      });\n      next = targetElement;\n    }\n\n    if (next && (!relatedEvent || relatedEvent && container.dispatchEvent(new TabsterMoveFocusEvent({\n      by: \"mover\",\n      owner: container,\n      next,\n      relatedEvent\n    })))) {\n      if (scrollIntoViewArg !== undefined) {\n        scrollIntoView(this._win, next, scrollIntoViewArg);\n      }\n\n      if (relatedEvent) {\n        relatedEvent.preventDefault();\n        relatedEvent.stopImmediatePropagation();\n      }\n\n      nativeFocus(next);\n      return next;\n    }\n\n    return null;\n  }\n\n  async _isIgnoredInput(element, key) {\n    if (element.getAttribute(\"aria-expanded\") === \"true\" && element.hasAttribute(\"aria-activedescendant\")) {\n      // It is likely a combobox with expanded options and arrow keys are\n      // controlled by it.\n      return true;\n    }\n\n    if (matchesSelector(element, _inputSelector)) {\n      let selectionStart = 0;\n      let selectionEnd = 0;\n      let textLength = 0;\n      let asyncRet;\n\n      if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n        const type = element.type;\n        const value = element.value;\n        textLength = (value || \"\").length;\n\n        if (type === \"email\" || type === \"number\") {\n          // For these types Chromium doesn't provide selectionStart and selectionEnd.\n          // Hence the ugly workaround to find if the caret position is changed with\n          // the keypress.\n          // TODO: Have a look at range, week, time, time, date, datetime-local.\n          if (textLength) {\n            const selection = dom.getSelection(element);\n\n            if (selection) {\n              const initialLength = selection.toString().length;\n              const isBackward = key === Keys.ArrowLeft || key === Keys.ArrowUp;\n              selection.modify(\"extend\", isBackward ? \"backward\" : \"forward\", \"character\");\n\n              if (initialLength !== selection.toString().length) {\n                // The caret is moved, so, we're not on the edge of the value.\n                // Restore original selection.\n                selection.modify(\"extend\", isBackward ? \"forward\" : \"backward\", \"character\");\n                return true;\n              } else {\n                textLength = 0;\n              }\n            }\n          }\n        } else {\n          const selStart = element.selectionStart;\n\n          if (selStart === null) {\n            // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n            return type === \"hidden\";\n          }\n\n          selectionStart = selStart || 0;\n          selectionEnd = element.selectionEnd || 0;\n        }\n      } else if (element.contentEditable === \"true\") {\n        asyncRet = new (getPromise(this._win))(resolve => {\n          this._ignoredInputResolve = value => {\n            delete this._ignoredInputResolve;\n            resolve(value);\n          };\n\n          const win = this._win();\n\n          if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n          }\n\n          const {\n            anchorNode: prevAnchorNode,\n            focusNode: prevFocusNode,\n            anchorOffset: prevAnchorOffset,\n            focusOffset: prevFocusOffset\n          } = dom.getSelection(element) || {}; // Get selection gives incorrect value if we call it syncronously onKeyDown.\n\n          this._ignoredInputTimer = win.setTimeout(() => {\n            var _a, _b, _c;\n\n            delete this._ignoredInputTimer;\n            const {\n              anchorNode,\n              focusNode,\n              anchorOffset,\n              focusOffset\n            } = dom.getSelection(element) || {};\n\n            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {\n              (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n              return;\n            }\n\n            selectionStart = anchorOffset || 0;\n            selectionEnd = focusOffset || 0;\n            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;\n\n            if (anchorNode && focusNode) {\n              if (dom.nodeContains(element, anchorNode) && dom.nodeContains(element, focusNode)) {\n                if (anchorNode !== element) {\n                  let anchorFound = false;\n\n                  const addOffsets = node => {\n                    if (node === anchorNode) {\n                      anchorFound = true;\n                    } else if (node === focusNode) {\n                      return true;\n                    }\n\n                    const nodeText = node.textContent;\n\n                    if (nodeText && !dom.getFirstChild(node)) {\n                      const len = nodeText.length;\n\n                      if (anchorFound) {\n                        if (focusNode !== anchorNode) {\n                          selectionEnd += len;\n                        }\n                      } else {\n                        selectionStart += len;\n                        selectionEnd += len;\n                      }\n                    }\n\n                    let stop = false;\n\n                    for (let e = dom.getFirstChild(node); e && !stop; e = e.nextSibling) {\n                      stop = addOffsets(e);\n                    }\n\n                    return stop;\n                  };\n\n                  addOffsets(element);\n                }\n              }\n            }\n\n            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);\n          }, 0);\n        });\n      }\n\n      if (asyncRet && !(await asyncRet)) {\n        return true;\n      }\n\n      if (selectionStart !== selectionEnd) {\n        return true;\n      }\n\n      if (selectionStart > 0 && (key === Keys.ArrowLeft || key === Keys.ArrowUp || key === Keys.Home)) {\n        return true;\n      }\n\n      if (selectionStart < textLength && (key === Keys.ArrowRight || key === Keys.ArrowDown || key === Keys.End)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction observeMutations(doc, tabster, updateTabsterByAttribute, syncState) {\n  if (typeof MutationObserver === \"undefined\") {\n    return () => {\n      /* Noop */\n    };\n  }\n\n  const getWindow = tabster.getWindow;\n  let elementByUId;\n\n  const onMutation = mutations => {\n    var _a, _b, _c, _d, _e;\n\n    const removedNodes = new Set();\n\n    for (const mutation of mutations) {\n      const target = mutation.target;\n      const removed = mutation.removedNodes;\n      const added = mutation.addedNodes;\n\n      if (mutation.type === \"attributes\") {\n        if (mutation.attributeName === TABSTER_ATTRIBUTE_NAME) {\n          // removedNodes helps to make sure we are not recreating things\n          // for the removed elements.\n          // For some reason, if we do removeChild() and setAttribute() on the\n          // removed child in the same tick, both the child removal and the attribute\n          // change will be present in the mutation records. And the attribute change\n          // will follow the child removal.\n          // So, we remember the removed nodes and ignore attribute changes for them.\n          if (!removedNodes.has(target)) {\n            updateTabsterByAttribute(tabster, target);\n          }\n        }\n      } else {\n        for (let i = 0; i < removed.length; i++) {\n          const removedNode = removed[i];\n          removedNodes.add(removedNode);\n          updateTabsterElements(removedNode, true);\n          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);\n        }\n\n        for (let i = 0; i < added.length; i++) {\n          updateTabsterElements(added[i]);\n          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);\n        }\n      }\n    }\n\n    removedNodes.clear();\n    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();\n  };\n\n  function updateTabsterElements(node, removed) {\n    if (!elementByUId) {\n      elementByUId = getInstanceContext(getWindow).elementByUId;\n    }\n\n    processNode(node, removed);\n    const walker = createElementTreeWalker(doc, node, element => {\n      return processNode(element, removed);\n    });\n\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n\n  function processNode(element, removed) {\n    var _a;\n\n    if (!element.getAttribute) {\n      // It might actually be a text node.\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    const uid = element.__tabsterElementUID;\n\n    if (uid && elementByUId) {\n      if (removed) {\n        delete elementByUId[uid];\n      } else {\n        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n      }\n    }\n\n    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {\n      updateTabsterByAttribute(tabster, element, removed);\n    }\n\n    return NodeFilter.FILTER_SKIP;\n  }\n\n  const observer = dom.createMutationObserver(onMutation);\n\n  if (syncState) {\n    updateTabsterElements(getWindow().document.body);\n  }\n\n  observer.observe(doc, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: [TABSTER_ATTRIBUTE_NAME]\n  });\n  return () => {\n    observer.disconnect();\n  };\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _conditionCheckTimeout = 100;\nclass ObservedElementAPI extends Subscribable {\n  constructor(tabster) {\n    super();\n    this._waiting = {};\n    this._lastRequestFocusId = 0;\n    this._observedById = {};\n    this._observedByName = {};\n    this._currentRequestTimestamp = 0;\n\n    this._onFocus = e => {\n      if (e) {\n        const current = this._currentRequest;\n\n        if (current) {\n          const delta = Date.now() - this._currentRequestTimestamp;\n\n          const settleTime = 300;\n\n          if (delta >= settleTime) {\n            // Giving some time for the focus to settle before\n            // automatically cancelling the current request on focus change.\n            delete this._currentRequest;\n            current.cancel();\n          }\n        }\n      }\n    };\n\n    this.onObservedElementUpdate = element => {\n      var _a;\n\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      const uid = getElementUId(this._win, element);\n      let info = this._observedById[uid];\n\n      if (observed && documentContains(element.ownerDocument, element)) {\n        if (!info) {\n          info = this._observedById[uid] = {\n            element: new WeakHTMLElement(this._win, element)\n          };\n        }\n\n        observed.names.sort();\n        const observedNames = observed.names;\n        const prevNames = info.prevNames; // prevNames are already sorted\n\n        if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n          if (prevNames) {\n            prevNames.forEach(prevName => {\n              const obn = this._observedByName[prevName];\n\n              if (obn && obn[uid]) {\n                if (Object.keys(obn).length > 1) {\n                  delete obn[uid];\n                } else {\n                  delete this._observedByName[prevName];\n                }\n              }\n            });\n          }\n\n          info.prevNames = observedNames;\n        }\n\n        observedNames.forEach(observedName => {\n          let obn = this._observedByName[observedName];\n\n          if (!obn) {\n            obn = this._observedByName[observedName] = {};\n          } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n          obn[uid] = info;\n\n          this._waitConditional(observedName);\n        });\n      } else if (info) {\n        const prevNames = info.prevNames;\n\n        if (prevNames) {\n          prevNames.forEach(prevName => {\n            const obn = this._observedByName[prevName];\n\n            if (obn && obn[uid]) {\n              if (Object.keys(obn).length > 1) {\n                delete obn[uid];\n              } else {\n                delete this._observedByName[prevName];\n              }\n            }\n          });\n        }\n\n        delete this._observedById[uid];\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n\n  dispose() {\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    for (const key of Object.keys(this._waiting)) {\n      this._rejectWaiting(key);\n    }\n\n    this._observedById = {};\n    this._observedByName = {};\n  }\n\n  _rejectWaiting(key, shouldResolve) {\n    const w = this._waiting[key];\n\n    if (w) {\n      const win = this._win();\n\n      if (w.timer) {\n        win.clearTimeout(w.timer);\n      }\n\n      if (w.conditionTimer) {\n        win.clearTimeout(w.conditionTimer);\n      }\n\n      if (!shouldResolve && w.reject) {\n        w.reject();\n      } else if (shouldResolve && w.resolve) {\n        w.resolve(null);\n      }\n\n      delete this._waiting[key];\n    }\n  }\n\n  _isObservedNamesUpdated(cur, prev) {\n    if (!prev || cur.length !== prev.length) {\n      return true;\n    }\n\n    for (let i = 0; i < cur.length; ++i) {\n      if (cur[i] !== prev[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Returns existing element by observed name\r\n   *\r\n   * @param observedName An observed name\r\n   * @param accessibility Optionally, return only if the element is accessible or focusable\r\n   * @returns HTMLElement | null\r\n   */\n\n\n  getElement(observedName, accessibility) {\n    const o = this._observedByName[observedName];\n\n    if (o) {\n      for (const uid of Object.keys(o)) {\n        let el = o[uid].element.get() || null;\n\n        if (el) {\n          if (accessibility === ObservedElementAccessibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccessibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {\n            el = null;\n          }\n        } else {\n          delete o[uid];\n          delete this._observedById[uid];\n        }\n\n        return el;\n      }\n    }\n\n    return null;\n  }\n  /**\r\n   * Waits for the element to appear in the DOM and returns it.\r\n   *\r\n   * @param observedName An observed name\r\n   * @param timeout Wait no longer than this timeout\r\n   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\r\n   * @returns Promise<HTMLElement | null>\r\n   */\n\n\n  waitElement(observedName, timeout, accessibility) {\n    const el = this.getElement(observedName, accessibility);\n\n    if (el) {\n      return {\n        result: getPromise(this._win).resolve(el),\n        cancel: () => {\n          /**/\n        },\n        status: ObservedElementRequestStatuses.Succeeded\n      };\n    }\n\n    let prefix;\n\n    if (accessibility === ObservedElementAccessibilities.Accessible) {\n      prefix = \"a\";\n    } else if (accessibility === ObservedElementAccessibilities.Focusable) {\n      prefix = \"f\";\n    } else {\n      prefix = \"_\";\n    }\n\n    const key = prefix + observedName;\n    let w = this._waiting[key];\n\n    if (w && w.request) {\n      return w.request;\n    }\n\n    w = this._waiting[key] = {\n      timer: this._win().setTimeout(() => {\n        if (w.conditionTimer) {\n          this._win().clearTimeout(w.conditionTimer);\n        }\n\n        delete this._waiting[key];\n\n        if (w.request) {\n          w.request.status = ObservedElementRequestStatuses.TimedOut;\n        }\n\n        if (w.resolve) {\n          w.resolve(null);\n        }\n      }, timeout)\n    };\n    const promise = new (getPromise(this._win))((resolve, reject) => {\n      w.resolve = resolve;\n      w.reject = reject;\n    });\n    const request = {\n      result: promise,\n      cancel: () => {\n        if (request.status === ObservedElementRequestStatuses.Waiting) {\n          // cancel() function is callable by user, someone might call it after request is finished,\n          // we are making sure that status of a finished request is not overriden.\n          request.status = ObservedElementRequestStatuses.Canceled;\n        }\n\n        this._rejectWaiting(key, true);\n      },\n      status: ObservedElementRequestStatuses.Waiting\n    };\n    w.request = request;\n\n    if (accessibility && this.getElement(observedName)) {\n      // If the observed element is alread in DOM, but not accessible yet,\n      // we need to run the wait logic.\n      this._waitConditional(observedName);\n    }\n\n    return request;\n  }\n\n  requestFocus(observedName, timeout, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    const requestId = ++this._lastRequestFocusId;\n    const currentRequestFocus = this._currentRequest;\n\n    if (currentRequestFocus) {\n      currentRequestFocus.cancel();\n    }\n\n    const request = this.waitElement(observedName, timeout, ObservedElementAccessibilities.Focusable);\n    this._currentRequest = request;\n    this._currentRequestTimestamp = Date.now();\n    const ret = {\n      result: request.result.then(element => this._lastRequestFocusId === requestId && element ? this._tabster.focusedElement.focus(element, true, undefined, options.preventScroll) : false),\n      cancel: () => {\n        request.cancel();\n      },\n      status: request.status\n    };\n    request.result.finally(() => {\n      if (this._currentRequest === request) {\n        delete this._currentRequest;\n      }\n\n      ret.status = request.status;\n    });\n    return ret;\n  }\n\n  _waitConditional(observedName) {\n    const waitingElementKey = \"_\" + observedName;\n    const waitingAccessibleElementKey = \"a\" + observedName;\n    const waitingFocusableElementKey = \"f\" + observedName;\n    const waitingElement = this._waiting[waitingElementKey];\n    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];\n    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];\n\n    const win = this._win();\n\n    const resolve = (element, key, waiting, accessibility) => {\n      var _a;\n\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n\n      if (!observed || !observed.names.includes(observedName)) {\n        return;\n      }\n\n      if (waiting.timer) {\n        win.clearTimeout(waiting.timer);\n      }\n\n      delete this._waiting[key];\n\n      if (waiting.request) {\n        waiting.request.status = ObservedElementRequestStatuses.Succeeded;\n      }\n\n      if (waiting.resolve) {\n        waiting.resolve(element);\n      }\n\n      this.trigger(element, {\n        names: [observedName],\n        details: observed.details,\n        accessibility\n      });\n    };\n\n    if (waitingElement) {\n      const element = this.getElement(observedName);\n\n      if (element && documentContains(element.ownerDocument, element)) {\n        resolve(element, waitingElementKey, waitingElement, ObservedElementAccessibilities.Any);\n      }\n    }\n\n    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {\n      const resolveAccessible = () => {\n        const element = this.getElement(observedName);\n\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {\n          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccessibilities.Accessible);\n        } else {\n          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);\n        }\n      };\n\n      resolveAccessible();\n    }\n\n    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {\n      const resolveFocusable = () => {\n        const element = this.getElement(observedName);\n\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {\n          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccessibilities.Focusable);\n        } else {\n          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);\n        }\n      };\n\n      resolveFocusable();\n    }\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst defaultProps = {\n  areaClass: \"tabster-focus-outline-area\",\n  outlineClass: \"tabster-focus-outline\",\n  outlineColor: \"#ff4500\",\n  outlineWidth: 2,\n  zIndex: 2147483647\n};\nlet _props = defaultProps;\n\nclass OutlinePosition {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n\n  equalsTo(other) {\n    return this.left === other.left && this.top === other.top && this.right === other.right && this.bottom === other.bottom;\n  }\n\n  clone() {\n    return new OutlinePosition(this.left, this.top, this.right, this.bottom);\n  }\n\n}\n\nclass OutlineAPI {\n  constructor(tabster) {\n    this._isVisible = false;\n    this._allOutlineElements = [];\n\n    this._init = () => {\n      this._tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n\n      this._tabster.focusedElement.subscribe(this._onFocus);\n\n      const win = this._win();\n\n      win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n      if (this._fullScreenEventName) {\n        win.document.addEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n      }\n    };\n\n    this._onFullScreenChanged = e => {\n      if (!this._fullScreenElementName || !e.target) {\n        return;\n      }\n\n      const target = e.target.body || e.target;\n\n      const outlineElements = this._getDOM(target);\n\n      if (target.ownerDocument && outlineElements) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fsElement = target.ownerDocument[this._fullScreenElementName];\n\n        if (fsElement) {\n          fsElement.appendChild(outlineElements.container);\n          this._fullScreenElement = fsElement;\n        } else {\n          target.ownerDocument.body.appendChild(outlineElements.container);\n          this._fullScreenElement = undefined;\n        }\n      }\n    };\n\n    this._onKeyboardNavigationStateChanged = () => {\n      this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    this._onFocus = e => {\n      if (!this._updateElement(e) && this._isVisible) {\n        this._setVisibility(false);\n      }\n    };\n\n    this._onScroll = e => {\n      if (!this._outlinedElement || !OutlineAPI._isParentChild(e.target, this._outlinedElement)) {\n        return;\n      }\n\n      this._curPos = undefined;\n\n      this._setOutlinePosition();\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(this._init);\n\n    if (typeof document !== \"undefined\") {\n      if (\"onfullscreenchange\" in document) {\n        this._fullScreenEventName = \"fullscreenchange\";\n        this._fullScreenElementName = \"fullscreenElement\";\n      } else if (\"onwebkitfullscreenchange\" in document) {\n        this._fullScreenEventName = \"webkitfullscreenchange\";\n        this._fullScreenElementName = \"webkitFullscreenElement\";\n      } else if (\"onmozfullscreenchange\" in document) {\n        this._fullScreenEventName = \"mozfullscreenchange\";\n        this._fullScreenElementName = \"mozFullScreenElement\";\n      } else if (\"onmsfullscreenchange\" in document) {\n        this._fullScreenEventName = \"msfullscreenchange\";\n        this._fullScreenElementName = \"msFullscreenElement\";\n      }\n    }\n  }\n\n  setup(props) {\n    _props = { ..._props,\n      ...props\n    };\n\n    const win = this._win();\n\n    if (!win.__tabsterOutline) {\n      win.__tabsterOutline = {};\n    }\n\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(win.document, _props);\n    }\n\n    if (!props || !props.areaClass) {\n      win.document.body.classList.add(defaultProps.areaClass);\n    } else {\n      win.document.body.classList.remove(defaultProps.areaClass);\n    }\n  }\n\n  dispose() {\n    const win = this._win();\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n\n    this._tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    win.removeEventListener(\"scroll\", this._onScroll, true);\n\n    if (this._fullScreenEventName) {\n      win.document.removeEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n    }\n\n    this._allOutlineElements.forEach(outlineElements => this._removeDOM(outlineElements.container));\n\n    this._allOutlineElements = [];\n    delete this._outlinedElement;\n    delete this._curPos;\n    delete this._curOutlineElements;\n    delete this._fullScreenElement;\n  }\n\n  _shouldShowCustomOutline(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n    if (tabsterOnElement && tabsterOnElement.outline && tabsterOnElement.outline.isIgnored) {\n      return false;\n    }\n\n    for (let i = element; i; i = i.parentElement) {\n      if (i.classList && i.classList.contains(_props.areaClass)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _updateElement(e) {\n    this._outlinedElement = undefined;\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      this._updateTimer = undefined;\n    }\n\n    this._curPos = undefined;\n\n    if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      return false;\n    }\n\n    if (e) {\n      // TODO: It's hard (and not necessary) to come up with every possible\n      // condition when there should be no outline, it's better to add an\n      // API to customize the ignores.\n      if (e.tagName === \"INPUT\") {\n        const inputType = e.type;\n        const outlinedInputTypes = {\n          button: true,\n          checkbox: true,\n          file: true,\n          image: true,\n          radio: true,\n          range: true,\n          reset: true,\n          submit: true\n        };\n\n        if (!(inputType in outlinedInputTypes)) {\n          return false;\n        }\n      } else if (e.tagName === \"TEXTAREA\" || e.contentEditable === \"true\" || e.tagName === \"IFRAME\") {\n        return false;\n      }\n\n      if (!this._shouldShowCustomOutline(e)) {\n        return false;\n      }\n\n      if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n        this._outlinedElement = e;\n\n        this._updateOutline();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _updateOutline() {\n    this._setOutlinePosition();\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      this._updateTimer = undefined;\n    }\n\n    if (!this._outlinedElement) {\n      return;\n    }\n\n    this._updateTimer = this._win().setTimeout(() => {\n      this._updateTimer = undefined;\n\n      this._updateOutline();\n    }, 30);\n  }\n\n  _setVisibility(visible) {\n    this._isVisible = visible;\n\n    if (this._curOutlineElements) {\n      if (visible) {\n        this._curOutlineElements.container.classList.add(`${_props.outlineClass}_visible`);\n      } else {\n        this._curOutlineElements.container.classList.remove(`${_props.outlineClass}_visible`);\n\n        this._curPos = undefined;\n      }\n    }\n  }\n\n  _setOutlinePosition() {\n    if (!this._outlinedElement) {\n      return;\n    }\n\n    let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n    const position = new OutlinePosition(boundingRect.left, boundingRect.top, boundingRect.right, boundingRect.bottom);\n\n    if (this._curPos && position.equalsTo(this._curPos)) {\n      return;\n    }\n\n    const outlineElements = this._getDOM(this._outlinedElement);\n\n    const win = this._outlinedElement.ownerDocument && this._outlinedElement.ownerDocument.defaultView;\n\n    if (!outlineElements || !win) {\n      return;\n    }\n\n    if (this._curOutlineElements !== outlineElements) {\n      this._setVisibility(false);\n\n      this._curOutlineElements = outlineElements;\n    }\n\n    this._curPos = position;\n    const p = position.clone();\n    let hasAbsolutePositionedParent = false;\n    let hasFixedPositionedParent = false;\n    const container = outlineElements.container;\n    const scrollingElement = container && container.ownerDocument && container.ownerDocument.scrollingElement;\n\n    if (!scrollingElement) {\n      return;\n    }\n\n    for (let parent = this._outlinedElement.parentElement; parent && parent.nodeType === Node.ELEMENT_NODE; parent = parent.parentElement) {\n      // The element might be partially visible within its scrollable parent,\n      // reduce the bounding rect if this is the case.\n      if (parent === this._fullScreenElement) {\n        break;\n      }\n\n      boundingRect = getBoundingRect(this._win, parent);\n      const win = parent.ownerDocument && parent.ownerDocument.defaultView;\n\n      if (!win) {\n        return;\n      }\n\n      const computedStyle = win.getComputedStyle(parent);\n      const position = computedStyle.position;\n\n      if (position === \"absolute\") {\n        hasAbsolutePositionedParent = true;\n      } else if (position === \"fixed\" || position === \"sticky\") {\n        hasFixedPositionedParent = true;\n      }\n\n      if (computedStyle.overflow === \"visible\") {\n        continue;\n      }\n\n      if (!hasAbsolutePositionedParent && !hasFixedPositionedParent || computedStyle.overflow === \"hidden\") {\n        if (boundingRect.left > p.left) {\n          p.left = boundingRect.left;\n        }\n\n        if (boundingRect.top > p.top) {\n          p.top = boundingRect.top;\n        }\n\n        if (boundingRect.right < p.right) {\n          p.right = boundingRect.right;\n        }\n\n        if (boundingRect.bottom < p.bottom) {\n          p.bottom = boundingRect.bottom;\n        }\n      }\n    }\n\n    const allRect = getBoundingRect(this._win, scrollingElement);\n    const allWidth = allRect.left + allRect.right;\n    const allHeight = allRect.top + allRect.bottom;\n    const ow = _props.outlineWidth;\n    p.left = p.left > ow ? p.left - ow : 0;\n    p.top = p.top > ow ? p.top - ow : 0;\n    p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n    p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n    const width = p.right - p.left;\n    const height = p.bottom - p.top;\n\n    if (width > ow * 2 && height > ow * 2) {\n      const leftBorderNode = outlineElements.left;\n      const topBorderNode = outlineElements.top;\n      const rightBorderNode = outlineElements.right;\n      const bottomBorderNode = outlineElements.bottom;\n      const sx = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageXOffset;\n      const sy = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageYOffset;\n      container.style.position = hasFixedPositionedParent ? \"fixed\" : \"absolute\";\n      container.style.background = _props.outlineColor;\n      leftBorderNode.style.width = rightBorderNode.style.width = topBorderNode.style.height = bottomBorderNode.style.height = _props.outlineWidth + \"px\";\n      leftBorderNode.style.left = topBorderNode.style.left = bottomBorderNode.style.left = p.left + sx + \"px\";\n      rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n      leftBorderNode.style.top = rightBorderNode.style.top = topBorderNode.style.top = p.top + sy + \"px\";\n      bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n      leftBorderNode.style.height = rightBorderNode.style.height = height + \"px\";\n      topBorderNode.style.width = bottomBorderNode.style.width = width + \"px\";\n\n      this._setVisibility(true);\n    } else {\n      this._setVisibility(false);\n    }\n  }\n\n  _getDOM(contextElement) {\n    const doc = contextElement.ownerDocument;\n    const win = doc && doc.defaultView;\n\n    if (!doc || !win || !win.__tabsterOutline) {\n      return undefined;\n    }\n\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(doc, _props);\n    }\n\n    if (!win.__tabsterOutline.elements) {\n      const outlineElements = {\n        container: doc.createElement(\"div\"),\n        left: doc.createElement(\"div\"),\n        top: doc.createElement(\"div\"),\n        right: doc.createElement(\"div\"),\n        bottom: doc.createElement(\"div\")\n      };\n      outlineElements.container.className = _props.outlineClass;\n      outlineElements.left.className = `${_props.outlineClass}__left`;\n      outlineElements.top.className = `${_props.outlineClass}__top`;\n      outlineElements.right.className = `${_props.outlineClass}__right`;\n      outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n      outlineElements.container.appendChild(outlineElements.left);\n      outlineElements.container.appendChild(outlineElements.top);\n      outlineElements.container.appendChild(outlineElements.right);\n      outlineElements.container.appendChild(outlineElements.bottom);\n      doc.body.appendChild(outlineElements.container);\n      win.__tabsterOutline.elements = outlineElements; // TODO: Make a garbage collector to remove the references\n      // to the outlines which are nowhere in the DOM anymore.\n\n      this._allOutlineElements.push(outlineElements);\n    }\n\n    return win.__tabsterOutline.elements;\n  }\n\n  _removeDOM(contextElement) {\n    const win = contextElement.ownerDocument && contextElement.ownerDocument.defaultView;\n    const outline = win && win.__tabsterOutline;\n\n    if (!outline) {\n      return;\n    }\n\n    if (outline.style && outline.style.parentNode) {\n      outline.style.parentNode.removeChild(outline.style);\n      delete outline.style;\n    }\n\n    const outlineElements = outline && outline.elements;\n\n    if (outlineElements) {\n      if (outlineElements.container.parentNode) {\n        outlineElements.container.parentNode.removeChild(outlineElements.container);\n      }\n\n      delete outline.elements;\n    }\n  }\n\n  static _isParentChild(parent, child) {\n    return child === parent || // tslint:disable-next-line:no-bitwise\n    !!(parent.compareDocumentPosition(child) & document.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n}\n\nfunction appendStyles(document, props) {\n  const style = document.createElement(\"style\");\n  style.type = \"text/css\";\n  style.appendChild(document.createTextNode(getOutlineStyles(props)));\n  document.head.appendChild(style);\n  return style;\n}\n\nfunction getOutlineStyles(props) {\n  return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Allows default or user focus behaviour on the DOM subtree\r\n * i.e. Tabster will not control focus events within an uncontrolled area\r\n */\nclass UncontrolledAPI {\n  constructor(isUncontrolledCompletely) {\n    this._isUncontrolledCompletely = isUncontrolledCompletely;\n  }\n\n  isUncontrolledCompletely(element, completely) {\n    var _a;\n\n    const isUncontrolledCompletely = (_a = this._isUncontrolledCompletely) === null || _a === void 0 ? void 0 : _a.call(this, element, completely); // If isUncontrolledCompletely callback is not defined or returns undefined, then the default\n    // behaviour is to return the uncontrolled.completely value from the element.\n\n    return isUncontrolledCompletely === undefined ? completely : isUncontrolledCompletely;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass Restorer extends TabsterPart {\n  constructor(tabster, element, props) {\n    var _a;\n\n    super(tabster, element, props);\n    this._hasFocus = false;\n\n    this._onFocusOut = e => {\n      var _a;\n\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n      if (element && e.relatedTarget === null) {\n        element.dispatchEvent(new RestorerRestoreFocusEvent());\n      }\n\n      if (element && !dom.nodeContains(element, e.relatedTarget)) {\n        this._hasFocus = false;\n      }\n    };\n\n    this._onFocusIn = () => {\n      this._hasFocus = true;\n    };\n\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.addEventListener(\"focusout\", this._onFocusOut);\n      element === null || element === void 0 ? void 0 : element.addEventListener(\"focusin\", this._onFocusIn); // set hasFocus when the instance is created, in case focus has already moved within it\n\n      this._hasFocus = dom.nodeContains(element, element && dom.getActiveElement(element.ownerDocument));\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    if (this._props.type === RestorerTypes.Source) {\n      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n      element === null || element === void 0 ? void 0 : element.removeEventListener(\"focusout\", this._onFocusOut);\n      element === null || element === void 0 ? void 0 : element.removeEventListener(\"focusin\", this._onFocusIn);\n\n      if (this._hasFocus) {\n        const doc = this._tabster.getWindow().document;\n\n        doc.body.dispatchEvent(new RestorerRestoreFocusEvent());\n      }\n    }\n  }\n\n}\n\nclass History {\n  constructor(getWindow) {\n    this._stack = [];\n    this._getWindow = getWindow;\n  }\n  /**\r\n   * Push a weak element to the top of the history stack.\r\n   * If the stack is full, the bottom weak element is removed.\r\n   * If the element is already at the top of the stack, it is not duplicated.\r\n   */\n\n\n  push(element) {\n    var _a; // Don't duplicate the top of history\n\n\n    if (((_a = this._stack[this._stack.length - 1]) === null || _a === void 0 ? void 0 : _a.get()) === element) {\n      return;\n    }\n\n    if (this._stack.length > History.DEPTH) {\n      this._stack.shift();\n    }\n\n    this._stack.push(new WeakHTMLElement(this._getWindow, element));\n  }\n  /**\r\n   * Pop the first element from the history that satisfies the callback.\r\n   * The history is searched from the top to the bottom (from the most recent to the least recent).\r\n   *\r\n   * If a weak reference to the element is broken,\r\n   * or the element is no longer in the DOM,\r\n   * the element is removed from the top of the stack while popping.\r\n   *\r\n   * If no matching element is found, undefined is returned.\r\n   * If the stack is empty, undefined is returned.\r\n   */\n\n\n  pop(filter) {\n    if (filter === void 0) {\n      filter = () => true;\n    }\n\n    var _a;\n\n    const doc = this._getWindow().document;\n\n    for (let index = this._stack.length - 1; index >= 0; index--) {\n      const maybeElement = (_a = this._stack.pop()) === null || _a === void 0 ? void 0 : _a.get();\n\n      if (maybeElement && dom.nodeContains(doc.body, dom.getParentElement(maybeElement)) && filter(maybeElement)) {\n        return maybeElement;\n      }\n    }\n\n    return undefined;\n  }\n\n}\n\nHistory.DEPTH = 10;\nclass RestorerAPI {\n  constructor(tabster) {\n    this._onRestoreFocus = e => {\n      var _a, _b;\n\n      this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer); // ShadowDOM will have shadowRoot as e.target.\n\n\n      const source = e.composedPath()[0];\n\n      if (source) {\n        // source id must be recovered before source is removed from DOM\n        // otherwise it'll be unreachable\n        // (as tabster on element will not be available through getTabsterOnElement)\n        const sourceId = (_b = (_a = getTabsterOnElement(this._tabster, source)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps().id;\n\n        this._focusedElementState.requestAsyncFocus(AsyncFocusSources.Restorer, () => this._restoreFocus(source, sourceId), 0);\n      }\n    };\n\n    this._onFocusIn = element => {\n      var _a;\n\n      if (!element) {\n        return;\n      }\n\n      const tabsterAttribute = getTabsterOnElement(this._tabster, element);\n\n      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) {\n        return;\n      }\n\n      this._history.push(element);\n    };\n\n    this._restoreFocus = (source, sourceId) => {\n      var _a; // don't restore focus if focus isn't lost to body\n\n\n      const doc = this._getWindow().document;\n\n      if (dom.getActiveElement(doc) !== doc.body) {\n        return;\n      }\n\n      if ( // clicking on any empty space focuses body - this is can be a false positive\n      !this._keyboardNavState.isNavigatingWithKeyboard() && // Source no longer exists on DOM - always restore focus\n      dom.nodeContains(doc.body, source)) {\n        return;\n      }\n\n      const getId = element => {\n        var _a, _b;\n\n        return (_b = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps().id;\n      };\n\n      (_a = this._history.pop(target => sourceId === getId(target))) === null || _a === void 0 ? void 0 : _a.focus();\n    };\n\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n\n    this._getWindow().addEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);\n\n    this._history = new History(this._getWindow);\n    this._keyboardNavState = tabster.keyboardNavigation;\n    this._focusedElementState = tabster.focusedElement;\n\n    this._focusedElementState.subscribe(this._onFocusIn);\n  }\n\n  dispose() {\n    const win = this._getWindow();\n\n    this._focusedElementState.unsubscribe(this._onFocusIn);\n\n    this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);\n\n    win.removeEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);\n  }\n\n  createRestorer(element, props) {\n    const restorer = new Restorer(this._tabster, element, props); // Focus might already be on a restorer target when it gets created so the focusin will not do anything\n\n    if (props.type === RestorerTypes.Target && dom.getActiveElement(element.ownerDocument) === element) {\n      this._history.push(element);\n    }\n\n    return restorer;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getActiveElement(doc) {\n  var _a;\n\n  let activeElement = doc.activeElement;\n\n  while ((_a = activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement) {\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n\n  return activeElement;\n}\nfunction nodeContains(node, otherNode) {\n  var _a, _b;\n\n  if (!node || !otherNode) {\n    return false;\n  }\n\n  let currentNode = otherNode;\n\n  while (currentNode) {\n    if (currentNode === node) {\n      return true;\n    }\n\n    if (typeof currentNode.assignedElements !== \"function\" && ((_a = currentNode.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentNode)) {\n      // Element is slotted\n      currentNode = (_b = currentNode.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;\n    } else if (currentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n      // Element is in shadow root\n      currentNode = currentNode.host;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return false;\n}\nfunction getParentNode(node) {\n  if (!node) {\n    return null;\n  }\n\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {\n    return node.host;\n  }\n\n  return node.parentNode;\n}\nfunction getParentElement(element) {\n  for (let parentNode = getParentNode(element); parentNode; parentNode = getParentNode(parentNode)) {\n    if (parentNode.nodeType === Node.ELEMENT_NODE) {\n      return parentNode;\n    }\n  }\n\n  return null;\n}\nfunction getFirstChild(node) {\n  if (!node) {\n    return null;\n  }\n\n  if (node.shadowRoot) {\n    const child = getFirstChild(node.shadowRoot);\n\n    if (child) {\n      return child;\n    } // If the attached shadowRoot has no children, just try ordinary children,\n    // that might come after.\n\n  }\n\n  return node.firstChild;\n}\nfunction getLastChild$1(node) {\n  if (!node) {\n    return null;\n  }\n\n  if (!node.lastChild && node.shadowRoot) {\n    return getLastChild$1(node.shadowRoot);\n  }\n\n  return node.lastChild;\n}\nfunction getNextSibling(node) {\n  return (node === null || node === void 0 ? void 0 : node.nextSibling) || null;\n}\nfunction getPreviousSibling(node) {\n  var _a;\n\n  if (!node) {\n    return null;\n  }\n\n  let sibling = node.previousSibling;\n\n  if (!sibling && ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.shadowRoot)) {\n    sibling = getLastChild$1(node.parentElement.shadowRoot);\n  }\n\n  return sibling;\n}\nfunction getFirstElementChild(element) {\n  let child = getFirstChild(element);\n\n  while (child && child.nodeType !== Node.ELEMENT_NODE) {\n    child = getNextSibling(child);\n  }\n\n  return child;\n}\nfunction getLastElementChild(element) {\n  let child = getLastChild$1(element);\n\n  while (child && child.nodeType !== Node.ELEMENT_NODE) {\n    child = getPreviousSibling(child);\n  }\n\n  return child;\n}\nfunction getNextElementSibling(element) {\n  let sibling = getNextSibling(element);\n\n  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {\n    sibling = getNextSibling(sibling);\n  }\n\n  return sibling;\n}\nfunction getPreviousElementSibling(element) {\n  let sibling = getPreviousSibling(element);\n\n  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {\n    sibling = getPreviousSibling(sibling);\n  }\n\n  return sibling;\n}\nfunction appendChild(parent, child) {\n  const shadowRoot = parent.shadowRoot;\n  return shadowRoot ? shadowRoot.appendChild(child) : parent.appendChild(child);\n}\nfunction insertBefore(parent, child, referenceChild) {\n  const shadowRoot = parent.shadowRoot;\n  return shadowRoot ? shadowRoot.insertBefore(child, referenceChild) : parent.insertBefore(child, referenceChild);\n}\nfunction getSelection(ref) {\n  var _a;\n\n  const win = (_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n\n  if (!win) {\n    return null;\n  }\n\n  for (let el = ref; el; el = el.parentNode) {\n    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      const tmp = el; // ShadowRoot.getSelection() exists only in Chrome.\n\n      if (tmp.getSelection) {\n        return tmp.getSelection() || null;\n      }\n\n      break;\n    }\n  }\n\n  return win.getSelection() || null;\n}\nfunction getElementsByName(referenceElement, name) {\n  for (let el = referenceElement; el; el = el.parentNode) {\n    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      // Shadow root doesn't have getElementsByName()...\n      return el.querySelectorAll(`[name=${name}]`);\n    }\n  }\n\n  return referenceElement.ownerDocument.getElementsByName(name);\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nfunction getLastChild(container) {\n  let lastChild = null;\n\n  for (let i = getLastElementChild(container); i; i = getLastElementChild(i)) {\n    lastChild = i;\n  }\n\n  return lastChild || undefined;\n}\n\nclass ShadowTreeWalker {\n  constructor(doc, root, whatToShow, filter) {\n    this._walkerStack = [];\n    this._currentSetFor = new Set();\n\n    this._acceptNode = node => {\n      var _a;\n\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        const shadowRoot = node.shadowRoot;\n\n        if (shadowRoot) {\n          const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n            acceptNode: this._acceptNode\n          });\n\n          this._walkerStack.unshift(walker);\n\n          return NodeFilter.FILTER_ACCEPT;\n        } else {\n          if (typeof this.filter === \"function\") {\n            return this.filter(node);\n          } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {\n            return this.filter.acceptNode(node);\n          } else if (this.filter === null) {\n            return NodeFilter.FILTER_ACCEPT;\n          }\n        }\n      }\n\n      return NodeFilter.FILTER_SKIP;\n    };\n\n    this._doc = doc;\n    this.root = root;\n    this.filter = filter !== null && filter !== void 0 ? filter : null;\n    this.whatToShow = whatToShow !== null && whatToShow !== void 0 ? whatToShow : NodeFilter.SHOW_ALL;\n    this._currentNode = root;\n\n    this._walkerStack.unshift(doc.createTreeWalker(root, whatToShow, this._acceptNode));\n\n    const shadowRoot = root.shadowRoot;\n\n    if (shadowRoot) {\n      const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n        acceptNode: this._acceptNode\n      });\n\n      this._walkerStack.unshift(walker);\n    }\n  }\n\n  get currentNode() {\n    return this._currentNode;\n  }\n\n  set currentNode(node) {\n    if (!nodeContains(this.root, node)) {\n      throw new Error(\"Cannot set currentNode to a node that is not contained by the root node.\");\n    }\n\n    const walkers = [];\n    let curNode = node;\n    let currentWalkerCurrentNode = node;\n    this._currentNode = node;\n\n    while (curNode && curNode !== this.root) {\n      if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        const shadowRoot = curNode;\n\n        const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n          acceptNode: this._acceptNode\n        });\n\n        walkers.push(walker);\n        walker.currentNode = currentWalkerCurrentNode;\n\n        this._currentSetFor.add(walker);\n\n        curNode = currentWalkerCurrentNode = shadowRoot.host;\n      } else {\n        curNode = curNode.parentNode;\n      }\n    }\n\n    const walker = this._doc.createTreeWalker(this.root, this.whatToShow, {\n      acceptNode: this._acceptNode\n    });\n\n    walkers.push(walker);\n    walker.currentNode = currentWalkerCurrentNode;\n\n    this._currentSetFor.add(walker);\n\n    this._walkerStack = walkers;\n  }\n\n  firstChild() {\n    if (process.env.NODE_ENV === 'development') {\n      throw new Error(\"Method not implemented.\");\n    }\n\n    return null;\n  }\n\n  lastChild() {\n    if (process.env.NODE_ENV === 'development') {\n      throw new Error(\"Method not implemented.\");\n    }\n\n    return null;\n  }\n\n  nextNode() {\n    var _a;\n\n    const nextNode = this._walkerStack[0].nextNode();\n\n    if (nextNode) {\n      const shadowRoot = nextNode.shadowRoot;\n\n      if (shadowRoot) {\n        let nodeResult;\n\n        if (typeof this.filter === \"function\") {\n          nodeResult = this.filter(nextNode);\n        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {\n          nodeResult = this.filter.acceptNode(nextNode);\n        }\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          return nextNode;\n        } // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n\n\n        return this.nextNode();\n      }\n\n      return nextNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        return this.nextNode();\n      } else {\n        return null;\n      }\n    }\n  }\n\n  previousNode() {\n    var _a, _b;\n\n    const currentWalker = this._walkerStack[0];\n\n    if (currentWalker.currentNode === currentWalker.root) {\n      if (this._currentSetFor.has(currentWalker)) {\n        this._currentSetFor.delete(currentWalker);\n\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n\n          return this.previousNode();\n        } else {\n          return null;\n        }\n      }\n\n      const lastChild = getLastChild(currentWalker.root);\n\n      if (lastChild) {\n        currentWalker.currentNode = lastChild;\n        let nodeResult;\n\n        if (typeof this.filter === \"function\") {\n          nodeResult = this.filter(lastChild);\n        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {\n          nodeResult = this.filter.acceptNode(lastChild);\n        }\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          return lastChild;\n        }\n      }\n    }\n\n    const previousNode = currentWalker.previousNode();\n\n    if (previousNode) {\n      const shadowRoot = previousNode.shadowRoot;\n\n      if (shadowRoot) {\n        let nodeResult;\n\n        if (typeof this.filter === \"function\") {\n          nodeResult = this.filter(previousNode);\n        } else if ((_b = this.filter) === null || _b === void 0 ? void 0 : _b.acceptNode) {\n          nodeResult = this.filter.acceptNode(previousNode);\n        }\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          return previousNode;\n        } // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n\n\n        return this.previousNode();\n      }\n\n      return previousNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        return this.previousNode();\n      } else {\n        return null;\n      }\n    }\n  }\n\n  nextSibling() {\n    if (process.env.NODE_ENV === 'development') {\n      throw new Error(\"Method not implemented.\");\n    }\n\n    return null;\n  }\n\n  previousSibling() {\n    if (process.env.NODE_ENV === 'development') {\n      throw new Error(\"Method not implemented.\");\n    }\n\n    return null;\n  }\n\n  parentNode() {\n    if (process.env.NODE_ENV === 'development') {\n      throw new Error(\"Method not implemented.\");\n    }\n\n    return null;\n  }\n\n}\nfunction createShadowTreeWalker(doc, root, whatToShow, filter) {\n  return new ShadowTreeWalker(doc, root, whatToShow, filter);\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass ShadowMutationObserver {\n  static _overrideAttachShadow(win) {\n    const origAttachShadow = win.Element.prototype.attachShadow;\n\n    if (origAttachShadow.__origAttachShadow) {\n      return;\n    }\n\n    Element.prototype.attachShadow = function (options) {\n      const shadowRoot = origAttachShadow.call(this, options);\n\n      for (const shadowObserver of ShadowMutationObserver._shadowObservers) {\n        shadowObserver._addSubObserver(shadowRoot);\n      }\n\n      return shadowRoot;\n    };\n\n    Element.prototype.attachShadow.__origAttachShadow = origAttachShadow;\n  }\n\n  constructor(callback) {\n    this._isObserving = false;\n\n    this._callbackWrapper = (mutations, observer) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"childList\") {\n          const removed = mutation.removedNodes;\n          const added = mutation.addedNodes;\n\n          for (let i = 0; i < removed.length; i++) {\n            this._walkShadows(removed[i], true);\n          }\n\n          for (let i = 0; i < added.length; i++) {\n            this._walkShadows(added[i]);\n          }\n        }\n      }\n\n      this._callback(mutations, observer);\n    };\n\n    this._callback = callback;\n    this._observer = new MutationObserver(this._callbackWrapper);\n    this._subObservers = new Map();\n  }\n\n  _addSubObserver(shadowRoot) {\n    if (!this._options || !this._callback || this._subObservers.has(shadowRoot)) {\n      return;\n    }\n\n    if (this._options.subtree && nodeContains(this._root, shadowRoot)) {\n      const subObserver = new MutationObserver(this._callbackWrapper);\n\n      this._subObservers.set(shadowRoot, subObserver);\n\n      if (this._isObserving) {\n        subObserver.observe(shadowRoot, this._options);\n      }\n\n      this._walkShadows(shadowRoot);\n    }\n  }\n\n  disconnect() {\n    this._isObserving = false;\n    delete this._options;\n\n    ShadowMutationObserver._shadowObservers.delete(this);\n\n    for (const subObserver of this._subObservers.values()) {\n      subObserver.disconnect();\n    }\n\n    this._subObservers.clear();\n\n    this._observer.disconnect();\n  }\n\n  observe(target, options) {\n    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;\n    const win = doc === null || doc === void 0 ? void 0 : doc.defaultView;\n\n    if (!doc || !win) {\n      return;\n    }\n\n    ShadowMutationObserver._overrideAttachShadow(win);\n\n    ShadowMutationObserver._shadowObservers.add(this);\n\n    this._root = target;\n    this._options = options;\n    this._isObserving = true;\n\n    this._observer.observe(target, options);\n\n    this._walkShadows(target);\n  }\n\n  _walkShadows(target, remove) {\n    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;\n\n    if (!doc) {\n      return;\n    }\n\n    if (target === doc) {\n      target = doc.body;\n    } else {\n      const shadowRoot = target.shadowRoot;\n\n      if (shadowRoot) {\n        this._addSubObserver(shadowRoot);\n\n        return;\n      }\n    }\n\n    const walker = doc.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: node => {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          if (remove) {\n            const subObserver = this._subObservers.get(node);\n\n            if (subObserver) {\n              subObserver.disconnect();\n\n              this._subObservers.delete(node);\n            }\n          } else {\n            const shadowRoot = node.shadowRoot;\n\n            if (shadowRoot) {\n              this._addSubObserver(shadowRoot);\n            }\n          }\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    walker.nextNode();\n  }\n\n  takeRecords() {\n    const records = this._observer.takeRecords();\n\n    for (const subObserver of this._subObservers.values()) {\n      records.push(...subObserver.takeRecords());\n    }\n\n    return records;\n  }\n\n}\nShadowMutationObserver._shadowObservers = /*#__PURE__*/new Set();\nfunction createShadowMutationObserver(callback) {\n  return new ShadowMutationObserver(callback);\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction shadowQuerySelector(node, selector, all) {\n  // TODO: This is probably slow. Optimize to use each shadowRoot's querySelector/querySelectorAll\n  //       instead of walking the tree.\n  const elements = [];\n  walk(node, selector);\n  return elements;\n\n  function walk(from, selector) {\n    let el = null;\n    const walker = document.createTreeWalker(from, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: n => {\n        if (n.nodeType === Node.ELEMENT_NODE) {\n          if (n.matches(selector)) {\n            el = n;\n            elements.push(el);\n            return all ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n          }\n\n          const shadowRoot = n.shadowRoot;\n\n          if (shadowRoot) {\n            walk(shadowRoot, selector);\n            return !all && elements.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n          }\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    walker.nextNode();\n  }\n}\n\nfunction querySelectorAll(node, selector) {\n  return shadowQuerySelector(node, selector, true);\n}\nfunction querySelector(node, selector) {\n  return shadowQuerySelector(node, selector, false)[0] || null;\n}\nfunction getElementById(doc, id) {\n  return querySelector(doc, \"#\" + id);\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar shadowDOMAPI = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createTreeWalker: createShadowTreeWalker,\n    createMutationObserver: createShadowMutationObserver,\n    appendChild: appendChild,\n    getActiveElement: getActiveElement,\n    getFirstChild: getFirstChild,\n    getFirstElementChild: getFirstElementChild,\n    getLastChild: getLastChild$1,\n    getLastElementChild: getLastElementChild,\n    getNextElementSibling: getNextElementSibling,\n    getNextSibling: getNextSibling,\n    getParentElement: getParentElement,\n    getParentNode: getParentNode,\n    getPreviousElementSibling: getPreviousElementSibling,\n    getPreviousSibling: getPreviousSibling,\n    getSelection: getSelection,\n    getElementsByName: getElementsByName,\n    insertBefore: insertBefore,\n    nodeContains: nodeContains,\n    getElementById: getElementById,\n    querySelector: querySelector,\n    querySelectorAll: querySelectorAll\n});\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass Tabster {\n  constructor(tabster) {\n    this.keyboardNavigation = tabster.keyboardNavigation;\n    this.focusedElement = tabster.focusedElement;\n    this.focusable = tabster.focusable;\n    this.root = tabster.root;\n    this.uncontrolled = tabster.uncontrolled;\n    this.core = tabster;\n  }\n\n}\n/**\r\n * Extends Window to include an internal Tabster instance.\r\n */\n\n\nclass TabsterCore {\n  constructor(win, props) {\n    var _a, _b;\n\n    this._forgetMemorizedElements = [];\n    this._wrappers = new Set();\n    this._initQueue = [];\n    this._version = \"8.5.0\";\n    this._noop = false;\n\n    this.getWindow = () => {\n      if (!this._win) {\n        throw new Error(\"Using disposed Tabster.\");\n      }\n\n      return this._win;\n    };\n\n    this._storage = createWeakMap(win);\n    this._win = win;\n    const getWindow = this.getWindow;\n\n    if (props === null || props === void 0 ? void 0 : props.DOMAPI) {\n      setDOMAPI({ ...props.DOMAPI\n      });\n    }\n\n    this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n    this.focusedElement = new FocusedElementState(this, getWindow);\n    this.focusable = new FocusableAPI(this);\n    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);\n    this.uncontrolled = new UncontrolledAPI( // TODO: Remove checkUncontrolledTrappingFocus in the next major version.\n    (props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus));\n    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;\n    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);\n    this._dummyObserver = new DummyInputObserver(getWindow);\n    this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : dom.getParentNode;\n    this.internal = {\n      stopObserver: () => {\n        if (this._unobserve) {\n          this._unobserve();\n\n          delete this._unobserve;\n        }\n      },\n      resumeObserver: syncState => {\n        if (!this._unobserve) {\n          const doc = getWindow().document;\n          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);\n        }\n      }\n    };\n    startFakeWeakRefsCleanup(getWindow); // Gives a tick to the host app to initialize other tabster\n    // APIs before tabster starts observing attributes.\n\n    this.queueInit(() => {\n      this.internal.resumeObserver(true);\n    });\n  }\n  /**\r\n   * Merges external props with the current props. Not all\r\n   * props can/should be mergeable, so let's add more as we move on.\r\n   * @param props Tabster props\r\n   */\n\n\n  _mergeProps(props) {\n    var _a;\n\n    if (!props) {\n      return;\n    }\n\n    this.getParent = (_a = props.getParent) !== null && _a !== void 0 ? _a : this.getParent;\n  }\n\n  createTabster(noRefCount, props) {\n    const wrapper = new Tabster(this);\n\n    if (!noRefCount) {\n      this._wrappers.add(wrapper);\n    }\n\n    this._mergeProps(props);\n\n    return wrapper;\n  }\n\n  disposeTabster(wrapper, allInstances) {\n    if (allInstances) {\n      this._wrappers.clear();\n    } else {\n      this._wrappers.delete(wrapper);\n    }\n\n    if (this._wrappers.size === 0) {\n      this.dispose();\n    }\n  }\n\n  dispose() {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n\n    this.internal.stopObserver();\n    const win = this._win;\n    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);\n    delete this._initTimer;\n    this._initQueue = [];\n    this._forgetMemorizedElements = [];\n\n    if (win && this._forgetMemorizedTimer) {\n      win.clearTimeout(this._forgetMemorizedTimer);\n      delete this._forgetMemorizedTimer;\n    }\n\n    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();\n    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();\n    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();\n    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();\n    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();\n    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();\n    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();\n    this.keyboardNavigation.dispose();\n    this.focusable.dispose();\n    this.focusedElement.dispose();\n    this.root.dispose();\n\n    this._dummyObserver.dispose();\n\n    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n    clearElementCache(this.getWindow);\n    this._storage = new WeakMap();\n\n    this._wrappers.clear();\n\n    if (win) {\n      disposeInstanceContext(win);\n      delete win.__tabsterInstance;\n      delete this._win;\n    }\n  }\n\n  storageEntry(element, addremove) {\n    const storage = this._storage;\n    let entry = storage.get(element);\n\n    if (entry) {\n      if (addremove === false && Object.keys(entry).length === 0) {\n        storage.delete(element);\n      }\n    } else if (addremove === true) {\n      entry = {};\n      storage.set(element, entry);\n    }\n\n    return entry;\n  }\n\n  forceCleanup() {\n    if (!this._win) {\n      return;\n    }\n\n    this._forgetMemorizedElements.push(this._win.document.body);\n\n    if (this._forgetMemorizedTimer) {\n      return;\n    }\n\n    this._forgetMemorizedTimer = this._win.setTimeout(() => {\n      delete this._forgetMemorizedTimer;\n\n      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {\n        clearElementCache(this.getWindow, el);\n        FocusedElementState.forgetMemorized(this.focusedElement, el);\n      }\n    }, 0);\n    cleanupFakeWeakRefs(this.getWindow, true);\n  }\n\n  queueInit(callback) {\n    var _a;\n\n    if (!this._win) {\n      return;\n    }\n\n    this._initQueue.push(callback);\n\n    if (!this._initTimer) {\n      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {\n        delete this._initTimer;\n        this.drainInitQueue();\n      }, 0);\n    }\n  }\n\n  drainInitQueue() {\n    if (!this._win) {\n      return;\n    }\n\n    const queue = this._initQueue; // Resetting the queue before calling the callbacks to avoid recursion.\n\n    this._initQueue = [];\n    queue.forEach(callback => callback());\n  }\n\n}\n\nfunction forceCleanup(tabster) {\n  // The only legit case for calling this method is when you've completely removed\n  // the application DOM and not going to add the new one for a while.\n  const tabsterCore = tabster.core;\n  tabsterCore.forceCleanup();\n}\n/**\r\n * Creates an instance of Tabster, returns the current window instance if it already exists.\r\n */\n\nfunction createTabster(win, props) {\n  let tabster = getCurrentTabster(win);\n\n  if (tabster) {\n    return tabster.createTabster(false, props);\n  }\n\n  tabster = new TabsterCore(win, props);\n  win.__tabsterInstance = tabster;\n  return tabster.createTabster();\n}\n/**\r\n * Returns an instance of Tabster if it was created before or null.\r\n */\n\nfunction getTabster(win) {\n  const tabster = getCurrentTabster(win);\n  return tabster ? tabster.createTabster(true) : null;\n}\nfunction getShadowDOMAPI() {\n  return shadowDOMAPI;\n}\n/**\r\n * Creates a new groupper instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getGroupper(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.groupper) {\n    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);\n  }\n\n  return tabsterCore.groupper;\n}\n/**\r\n * Creates a new mover instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getMover(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.mover) {\n    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n  }\n\n  return tabsterCore.mover;\n}\nfunction getOutline(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.outline) {\n    tabsterCore.outline = new OutlineAPI(tabsterCore);\n  }\n\n  return tabsterCore.outline;\n}\n/**\r\n * Creates a new new deloser instance or returns an existing one\r\n * @param tabster Tabster instance\r\n * @param props Deloser props\r\n */\n\nfunction getDeloser(tabster, props) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.deloser) {\n    tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n  }\n\n  return tabsterCore.deloser;\n}\n/**\r\n * Creates a new modalizer instance or returns an existing one\r\n * @param tabster Tabster instance\r\n * @param alwaysAccessibleSelector When Modalizer is active, we put\r\n * aria-hidden to everything else to hide it from screen readers. This CSS\r\n * selector allows to exclude some elements from this behaviour. For example,\r\n * this could be used to exclude aria-live region with the application-wide\r\n * status announcements.\r\n * @param accessibleCheck An optional callback that will be called when\r\n * active Modalizer wants to hide an element that doesn't belong to it from\r\n * the screen readers by setting aria-hidden. Similar to alwaysAccessibleSelector\r\n * but allows to address the elements programmatically rather than with a selector.\r\n * If the callback returns true, the element will not receive aria-hidden.\r\n */\n\nfunction getModalizer(tabster, // @deprecated use accessibleCheck.\nalwaysAccessibleSelector, accessibleCheck) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.modalizer) {\n    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);\n  }\n\n  return tabsterCore.modalizer;\n}\nfunction getObservedElement(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.observedElement) {\n    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n  }\n\n  return tabsterCore.observedElement;\n}\nfunction getCrossOrigin(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.crossOrigin) {\n    getDeloser(tabster);\n    getModalizer(tabster);\n    getMover(tabster);\n    getGroupper(tabster);\n    getOutline(tabster);\n    getObservedElement(tabster);\n    tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n  }\n\n  return tabsterCore.crossOrigin;\n}\nfunction getInternal(tabster) {\n  const tabsterCore = tabster.core;\n  return tabsterCore.internal;\n}\nfunction getRestorer(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.restorer) {\n    tabsterCore.restorer = new RestorerAPI(tabsterCore);\n  }\n\n  return tabsterCore.restorer;\n}\nfunction disposeTabster(tabster, allInstances) {\n  tabster.core.disposeTabster(tabster, allInstances);\n}\n/**\r\n * Returns an instance of Tabster if it already exists on the window .\r\n * @param win window instance that could contain an Tabster instance.\r\n */\n\nfunction getCurrentTabster(win) {\n  return win.__tabsterInstance;\n}\n/**\r\n * Allows to make Tabster non operational. Intended for performance debugging (and other\r\n * kinds of debugging), you can switch Tabster off without changing the application code\r\n * that consumes it.\r\n * @param tabster a reference created by createTabster().\r\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\r\n */\n\nfunction makeNoOp(tabster, noop) {\n  const core = tabster.core;\n\n  if (core._noop !== noop) {\n    core._noop = noop;\n\n    const processNode = element => {\n      if (!element.getAttribute) {\n        return NodeFilter.FILTER_SKIP;\n      }\n\n      if (getTabsterOnElement(core, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {\n        updateTabsterByAttribute(core, element);\n      }\n\n      return NodeFilter.FILTER_SKIP;\n    };\n\n    const doc = core.getWindow().document;\n    const body = doc.body;\n    processNode(body);\n    const walker = createElementTreeWalker(doc, body, processNode);\n\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n}\nfunction isNoOp(tabster) {\n  return tabster._noop;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar Types = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar EventsTypes = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new GroupperMoveFocusEvent(...)). */\n\nfunction dispatchGroupperMoveFocusEvent(target, action) {\n  return target.dispatchEvent(new GroupperMoveFocusEvent({\n    action\n  }));\n}\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new MoverMoveFocusEvent(...)). */\n\nfunction dispatchMoverMoveFocusEvent(target, key) {\n  return target.dispatchEvent(new MoverMoveFocusEvent({\n    key\n  }));\n}\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new MoverMemorizedElementEvent(...)). */\n\nfunction dispatchMoverMemorizedElementEvent(target, memorizedElement) {\n  return target.dispatchEvent(new MoverMemorizedElementEvent({\n    memorizedElement\n  }));\n}\n\nexport { AsyncFocusSources, DeloserFocusLostEvent, DeloserFocusLostEventName, DeloserRestoreFocusEvent, DeloserRestoreFocusEventName, DeloserStrategies, EventsTypes, FOCUSABLE_SELECTOR, GroupperMoveFocusActions, GroupperMoveFocusEvent, GroupperMoveFocusEventName, GroupperTabbabilities, ModalizerActiveEvent, ModalizerActiveEventName, ModalizerFocusInEventName, ModalizerFocusOutEventName, ModalizerInactiveEvent, ModalizerInactiveEventName, MoverDirections, MoverKeys, MoverMemorizedElementEvent, MoverMemorizedElementEventName, MoverMoveFocusEvent, MoverMoveFocusEventName, MoverStateEvent, MoverStateEventName, ObservedElementAccessibilities, ObservedElementRequestStatuses, RestoreFocusOrders, RestorerRestoreFocusEvent, RestorerRestoreFocusEventName, RestorerTypes, RootBlurEvent, RootBlurEventName, RootFocusEvent, RootFocusEventName, SysDummyInputsPositions, TABSTER_ATTRIBUTE_NAME, TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, TabsterCustomEvent, TabsterFocusInEvent, TabsterFocusInEventName, TabsterFocusOutEvent, TabsterFocusOutEventName, TabsterMoveFocusEvent, TabsterMoveFocusEventName, Types, Visibilities, createTabster, dispatchGroupperMoveFocusEvent, dispatchMoverMemorizedElementEvent, dispatchMoverMoveFocusEvent, disposeTabster, forceCleanup, getCrossOrigin, getDeloser, getDummyInputContainer, getGroupper, getInternal, getModalizer, getMover, getObservedElement, getOutline, getRestorer, getShadowDOMAPI, getTabster, getTabsterAttribute, isNoOp, makeNoOp, mergeTabsterProps, setTabsterAttribute };\n//# sourceMappingURL=tabster.esm.js.map\n"],"names":["TABSTER_ATTRIBUTE_NAME","FOCUSABLE_SELECTOR","join","AsyncFocusSources","RestorerTypes","Source","Target","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","getTabsterOnElement","tabster","element","_a","storageEntry","updateTabsterByAttribute","dispose","_b","newAttrValue","_noop","undefined","getAttribute","newAttr","entry","attr","string","newValue","JSON","parse","Error","object","e","tabsterOnElement","oldTabsterProps","newTabsterProps","key","Object","keys","root","onRoot","part","observedElement","onObservedElementUpdate","sys","deloser","setProps","createDeloser","createRoot","modalizer","createModalizer","restorer","createRestorer","focusable","groupper","createGroupper","mover","createMover","observed","uncontrolled","outline","console","error","length","MoverMoveFocusEventName","MoverMemorizedElementEventName","RestorerRestoreFocusEventName","CustomEvent_","CustomEvent","TabsterCustomEvent","constructor","type","detail","super","bubbles","cancelable","composed","this","details","TabsterFocusInEvent","TabsterFocusOutEvent","TabsterMoveFocusEvent","MoverStateEvent","ModalizerActiveEvent","ModalizerInactiveEvent","RestorerRestoreFocusEvent","RootFocusEvent","RootBlurEvent","dom","createMutationObserver","callback","MutationObserver","createTreeWalker","doc","whatToShow","filter","getParentNode","node","parentNode","getParentElement","parentElement","nodeContains","parent","child","contains","getActiveElement","activeElement","querySelector","selector","querySelectorAll","Array","prototype","slice","call","getElementById","id","getFirstChild","firstChild","getLastChild","lastChild","getNextSibling","nextSibling","getPreviousSibling","previousSibling","getFirstElementChild","firstElementChild","getLastElementChild","lastElementChild","getNextElementSibling","nextElementSibling","getPreviousElementSibling","previousElementSibling","appendChild","insertBefore","referenceChild","getSelection","ref","ownerDocument","getElementsByName","referenceElement","name","_isBrokenIE11","_DOMRect","DOMRect","x","y","width","height","left","top","right","bottom","_uidCounter","document","NodeFilter","SHOW_ELEMENT","getInstanceContext","getWindow","win","ctx","__tabsterInstanceContext","elementByUId","basics","Promise","WeakRef","containerBoundingRectCache","lastContainerBoundingRectCacheId","fakeWeakRefs","fakeWeakRefsStarted","FakeWeakRef","target","_target","deref","cleanup","fwr","forceRemove","documentContains","WeakHTMLElement","data","context","push","_ref","_data","get","getData","cleanupFakeWeakRefs","startFakeWeakRefsCleanup","getWeakRef","fakeWeakRefsTimer","setTimeout","createElementTreeWalker","acceptNode","nodeType","Node","ELEMENT_NODE","getBoundingRect","cacheId","__tabsterCacheId","cached","rect","scrollingElement","documentElement","clientWidth","clientHeight","r","getBoundingClientRect","Math","max","min","containerBoundingRectCacheTimer","window","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","totalIntersection","el","scrollWidth","scrollHeight","shouldIgnoreFocus","__shouldIgnoreFocus","getElementUId","uid","__tabsterElementUID","wnd","rnd","Uint32Array","crypto","getRandomValues","msCrypto","i","random","srnd","toString","Date","now","getUId","clearElementCache","wel","body","matchesSelector","matches","msMatchesSelector","webkitMatchesSelector","_lastTabsterPartId","TabsterPart","props","_tabster","_element","_props","getElement","getProps","DummyInput","isOutside","fixedTarget","_focusIn","_fixedTarget","input","onFocusIn","relatedTarget","_isBackward","_focusOut","useDefaultAction","onFocusOut","createElement","tabIndex","setAttribute","style","position","opacity","zIndex","setProperty","makeFocusIgnored","isFirst","_isPhantom","isPhantom","addEventListener","__tabsterDummyContainer","_disposeTimer","_clearDisposeTimeout","clearTimeout","removeEventListener","removeChild","setTopLeft","isIn","current","previous","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DummyInputManager","priority","outsideByDefault","callForDefaultAction","_instance","DummyInputManagerCore","_setHandlers","_onFocusIn","_onFocusOut","moveOut","backwards","moveOutWithDefaultAction","relatedEvent","getHandler","setTabbable","tabbable","moveWithPhantomDummy","moveOutOfElement","isBackward","tagName","potentialDummy","dummyFor","isFocusable","getDummyInputContainer","dispatchEvent","by","owner","next","addPhantomDummyWithTarget","sourceElement","targetElement","dummyParent","DummyInputObserver","_updateQueue","Set","_lastUpdateQueueTime","_changedParents","WeakSet","_dummyElements","_dummyCallbacks","WeakMap","_domChanged","has","add","_updateDummyInputsTimer","_win","dummyElement","dummy","set","domChanged","remove","delete","_updateTimer","clear","updatePositions","compute","_scheduledUpdatePositions","scrollTopLeftCache","Map","setTopLeftCallbacks","manager","_wrappers","_isOutside","_transformElements","dummyInput","_onFocus","first","_firstDummy","last","_lastDummy","_ensurePosition","firstInput","lastInput","toFocus","w","wrapper","_getCurrent","_addDummyInputs","_addTimer","_getWindow","_addTransformOffsets","_dummyObserver","_computeTransformOffsets","from","transformElements","newTransformElements","scrollTop","scrollLeft","scrollTopLeft","transform","getComputedStyle","_callForDefaultAction","instance","__tabsterDummy","forcedDummyPosition","dummyInputsPosition","force","_c","_d","sort","a","b","firstDummyInput","lastDummyInput","elementParent","getLastChild$2","augmentAttribute","value","ret","aug","origVal","removeAttribute","origValue","isRadio","getTabsterAttribute","plain","stringify","RootDummyManager","setFocused","_onDummyInputFocus","_setFocused","keyboardNavigation","setNavigatingWithKeyboard","focusedElement","getFirstOrLastTabbable","ignoreAccessibility","blur","Root","onDispose","_isFocused","hasFocused","_setFocusedTimer","_dummyManager","event","getParent","rootElement","curElement","composedPath","_onDispose","_sys","controlTab","rootDummyInputs","addDummyInputs","_add","_remove","dummyManager","RootAPI","autoRoot","_autoRootWaiting","_roots","_forceDummy","rootById","_autoRootCreate","_autoRootUnwait","_autoRoot","newProps","update","mergeTabsterProps","setTabsterAttribute","_onRootDispose","queueInit","forEach","rootId","newRoot","roots","getRootByUId","__tabsterInstance","getTabsterContext","options","checkRtl","drainInitQueue","groupperBeforeMover","modalizerInGroupper","dirRightToLeft","excludedFromMover","ignoreKeydown","dir","toLowerCase","excludeFromMover","curModalizer","curGroupper","curMover","isActive","tabbability","userId","activeId","assign","rootAPI","rtl","getRoot","removed","Subscribable","_callbacks","_val","subscribe","callbacks","indexOf","subscribeFirst","index","splice","unshift","unsubscribe","setVal","val","_callCallbacks","getVal","trigger","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","noAccessibleCheck","isVisible","isAccessible","elementDocument","computedStyle","defaultView","offsetParent","visibility","display","isDisplayNone","_isHidden","ignoreAriaDisabled","_isDisabled","hasAttribute","attrVal","isAugmented","findFirst","out","findElement","findLast","findNext","findPrev","findDefault","acceptCondition","isDefault","findAll","_findElements","found","isFindAll","currentElement","useActiveModalizer","modalizerId","onElement","elements","hasCustomCondition","acceptElementState","modalizerUserId","cachedGrouppers","cachedRadioGroups","walker","_acceptElement","prepareForNextElement","shouldContinueIfNotFound","foundElement","foundBackward","fromCtx","outOfDOMOrder","currentNode","FILTER_ACCEPT","skippedFocusable","previousNode","nextNode","state","FILTER_SKIP","FILTER_REJECT","rejectElementsFrom","currentCtx","result","fromMover","acceptElement","groupperElement","fromMoverElement","moverElement","checked","radioGroupName","radioGroup","radioButtons","buttons","getRadioButtonGroup","Keys","AsyncFocusIntentPriorityBySource","FocusedElementState","_init","_onKeyDown","_setFocusedElement","_onChanged","isFocusedProgrammatically","originalEvent","_validateFocusedElement","ctrlKey","contentEditable","shiftKey","findNextTabbable","nextElement","uncontrolledCompletelyContainer","uncontrolledOnElement","isUncontrolledCompletely","completely","getUncontrolledCompletelyContainer","nextUncontrolled","preventDefault","stopImmediatePropagation","_lastVal","d","lastCtx","asyncFocus","_asyncFocus","timeout","_lastResetElement","_nextVal","forgetMemorized","getFocusedElement","getLastFocusedElement","focus","noFocusedProgrammaticallyFlag","preventScroll","focusDefault","_focusFirstOrLast","focusFirst","focusLast","resetFocus","prevTabIndex","prevAriaHidden","_setOrRemoveAttribute","requestAsyncFocus","source","delay","currentAsyncFocus","cancelAsyncFocus","lastResetElement","nextVal","actualContainer","isTabbingTimer","_isTabbingTimer","isTabbing","callFindNext","what","parentCtx","currentScopeElement","newCurrent","findProps","findPropsOut","KeyboardNavigationState","_onChange","isNavigatingWithKeyboard","_keyborg","_wasFocusedCounter","_ariaHidden","ModalizerDummyManager","dummyContainer","Modalizer","activeElements","_wasFocused","_activeElements","makeActive","_isActive","map","_dispatchEvent","focused","noIncrement","isTrapped","allElements","defaultPrevented","eventDetail","ModalizerAPI","alwaysAccessibleSelector","accessibleCheck","_onModalizerDispose","_parts","_modalizers","activationHistory","_activationHistory","cleanActivationHistory","prevHistoryItem","modalizerUserIdFromHistory","prevActiveId","prevActive","values","setActive","focusedSince","m","f","handleKeyPress","augmentedMap","_augMap","tabsterOnFocusedElement","modalizerOnFocusedElement","parentModalizer","currentIsOthersAccessible","isAlwaysAccessible","_restoreModalizerFocusTimer","_restoreModalizerFocus","isOthersAccessible","_aug","_alwaysAccessibleSelector","_accessibleCheck","_hiddenUpdateTimer","hiddenUpdate","_hiddenUpdate","elementFromModalizer","noFocusFirst","noFocusDefault","modalizerRoot","isNoFocusFirst","isNoFocusDefault","activate","modalizerElementOrContainer","modalizerToActivate","currentModalizer","parts","visibleElements","hiddenElements","alwaysAccessibleElements","activeModalizerElements","modalizerParts","allVisibleElements","newAugmented","newAugmentedMap","toggle","hide","walk","skip","containsModalizer","containedByModalizer","elParent","c","__tabsterElementFlags","noDirectAriaHidden","outsideElement","DOCUMENT_POSITION_PRECEDING","_inputSelector","MoverDummyManager","getMemorized","_onFocusDummyInput","memorized","_getMemorized","Mover","_visible","_onIntersection","entries","newVisibility","fullyVisible","_fullyVisible","intersectionRatio","getState","visibilityTolerance","trackState","visibilityAware","_intersectionObserver","IntersectionObserver","threshold","_observeState","memorizeCurrent","_current","disconnect","_allElements","_unobserve","_setCurrentTimer","setCurrent","changed","_prevCurrent","weak","getCurrent","currentIsDummy","hasDefault","tabsterFocusable","updateQueue","observer","mutations","mutation","removedNodes","added","addedNodes","attributeName","requestUpdate","setElement","unobserve","observe","updateElement","addNewElements","getMoverGroupper","groupperFirstFocusable","getFirst","removeWalk","toe","childList","subtree","attributes","attributeFilter","isCurrent","MoverAPI","_onMoveFocus","_onMemorizedElement","_onMoverDispose","_movers","currentFocusableElement","deepestFocusableElement","async","_ignoredInputTimer","_ignoredInputResolve","altKey","metaKey","moverKey","_isIgnoredInput","_moveFocus","memorizedElement","moverId","newMover","moveFocus","fromElement","moverProps","direction","isBoth","isVertical","isHorizontal","isGridLinear","isGrid","isCyclic","cyclic","scrollIntoViewArg","focusedElementRect","focusedElementX1","focusedElementX2","ceil","floor","nextElementX1","nextElementX2","firstColumnX1","lastColumnX1","ax1","ay1","ax2","ay2","lastDistance","lastIntersection","bx1","by1","bx2","by2","xIntersectionWidth","minWidth","intersection","distance","xDistance","yDistance","sqrt","getDistance","alignToTop","scrollIntoView","asyncRet","selectionStart","selectionEnd","textLength","selection","initialLength","modify","selStart","resolve","anchorNode","prevAnchorNode","focusNode","prevFocusNode","anchorOffset","prevAnchorOffset","focusOffset","prevFocusOffset","textContent","anchorFound","addOffsets","nodeText","len","stop","UncontrolledAPI","_isUncontrolledCompletely","Restorer","_hasFocus","History","_stack","DEPTH","shift","pop","maybeElement","RestorerAPI","_onRestoreFocus","_focusedElementState","sourceId","_restoreFocus","tabsterAttribute","_history","_keyboardNavState","getId","ShadowMutationObserver","_overrideAttachShadow","origAttachShadow","Element","attachShadow","__origAttachShadow","shadowRoot","shadowObserver","_shadowObservers","_addSubObserver","_isObserving","_callbackWrapper","_walkShadows","_callback","_observer","_subObservers","_options","otherNode","assignedElements","assignedSlot","DOCUMENT_FRAGMENT_NODE","host","_root","subObserver","DOCUMENT_NODE","takeRecords","records","Tabster","core","TabsterCore","_forgetMemorizedElements","_initQueue","_version","_storage","createWeakMap","DOMAPI","domapi","setDOMAPI","checkUncontrolledCompletely","checkUncontrolledTrappingFocus","internal","stopObserver","resumeObserver","syncState","updateTabsterElements","processNode","_e","removedNode","observeMutations","_mergeProps","createTabster","noRefCount","disposeTabster","allInstances","size","_f","_g","_h","_initTimer","_forgetMemorizedTimer","crossOrigin","stopFakeWeakRefsCleanupAndClearStorage","disposeInstanceContext","addremove","storage","forceCleanup","queue","getCurrentTabster","getMover","tabsterCore","getModalizer","getRestorer"],"sourceRoot":""}